__NUXT_JSONP__("/wiki/content/UIKit-UISplit%E2%80%8BView%E2%80%8BController%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT,aU,aV){return {data:[{},{article:{slug:T,description:"个人感觉UISplitViewController是比较鸡肋的东西,开发中自定义split​View​Controller的时候比较常见。",title:U,layout:"page",date:V,toc:[{id:B,depth:t,text:B},{id:W,depth:t,text:X},{id:Y,depth:t,text:Z},{id:_,depth:t,text:$},{id:aa,depth:t,text:ab},{id:ac,depth:t,text:ad},{id:ae,depth:t,text:af}],body:{type:ag,children:[{type:b,tag:f,props:{},children:[{type:a,value:ah},{type:b,tag:d,props:{},children:[{type:a,value:C}]},{type:a,value:ai},{type:b,tag:d,props:{},children:[{type:a,value:j}]},{type:a,value:aj}]},{type:a,value:c},{type:a,value:c},{type:b,tag:u,props:{id:B},children:[{type:b,tag:i,props:{href:"#%E4%BB%8B%E7%BB%8D",ariaHidden:k,tabIndex:l},children:[{type:b,tag:e,props:{className:[m,n]},children:[]}]},{type:a,value:B}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:d,props:{},children:[{type:a,value:C}]},{type:a,value:"类是一个容器视图控制器，它显示一个"},{type:b,tag:d,props:{},children:[{type:a,value:ak}]},{type:a,value:"界面(主界面、详细界面)。在"},{type:b,tag:d,props:{},children:[{type:a,value:ak}]},{type:a,value:"界面中，主视图控制器（"},{type:b,tag:d,props:{},children:[{type:a,value:al}]},{type:a,value:"）的变化会驱动辅助视图控制器（"},{type:b,tag:d,props:{},children:[{type:a,value:am}]},{type:a,value:"）变化。 两个视图控制器("},{type:b,tag:d,props:{},children:[{type:a,value:al}]},{type:a,value:"控制器、"},{type:b,tag:d,props:{},children:[{type:a,value:am}]},{type:a,value:"控制器)的排列是可以控制的， 他们可以同时显示或者一次只显示一个。"},{type:b,tag:d,props:{},children:[{type:a,value:C}]},{type:a,value:"在iOS3.2的时候就有了，只不过iOS8才开始支持iPhone(比如在iPhone6 plus上显示视图和iPad很相似了)。"}]},{type:a,value:c},{type:b,tag:u,props:{id:W},children:[{type:b,tag:i,props:{href:"#overview",ariaHidden:k,tabIndex:l},children:[{type:b,tag:e,props:{className:[m,n]},children:[]}]},{type:a,value:X}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"在构建应用程序的用户界面时，"},{type:b,tag:d,props:{},children:[{type:a,value:j}]},{type:a,value:"通常是应用程序窗口(window)的根视图控制器。"},{type:b,tag:d,props:{},children:[{type:a,value:j}]},{type:a,value:"没有明显的外观，它的外观基本上是由它的子视图控制器(master、detail控制器)决定的。 你可以以"},{type:b,tag:d,props:{},children:[{type:a,value:"Interface Builder"}]},{type:a,value:"的方式或者代码的方式构建该控制器。"}]},{type:a,value:c},{type:b,tag:an,props:{},children:[{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"Note\n你不能把"},{type:b,tag:d,props:{},children:[{type:a,value:j}]},{type:a,value:"push到"},{type:b,tag:d,props:{},children:[{type:a,value:"navigationController"}]},{type:a,value:"的栈中\n尽管在一些容器视图控制器中，把"},{type:b,tag:d,props:{},children:[{type:a,value:j}]},{type:a,value:"当做子控制器这个操作是可行的，但是大多数情况不允许这么做。再次声明，"},{type:b,tag:d,props:{},children:[{type:a,value:j}]},{type:a,value:"通常配置为window的root控制器。 有关实现界面的方法的提示和指导，请参阅"},{type:b,tag:i,props:{href:"https:\u002F\u002Fdeveloper.apple.com\u002Fios\u002Fhuman-interface-guidelines\u002F",rel:[p,q,r],target:s},children:[{type:a,value:"iOS Human Interface Guidelines"}]},{type:a,value:D}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:d,props:{},children:[{type:a,value:j}]},{type:a,value:"基于可用空间确定其子视图控制器的排列:"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"在水平规则的环境中，"},{type:b,tag:d,props:{},children:[{type:a,value:j}]},{type:a,value:"尽可能并排地呈现其视图控制器(同时并排地显示master、detail控制器)。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"在水平紧凑的环境中，"},{type:b,tag:d,props:{},children:[{type:a,value:j}]},{type:a,value:"的行为更像导航控制器，最初显示主视图控制器，并根据需要"},{type:b,tag:d,props:{},children:[{type:a,value:ao}]},{type:a,value:ap},{type:b,tag:d,props:{},children:[{type:a,value:aq}]},{type:a,value:"第二个控制器。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"当显示在屏幕上时，"},{type:b,tag:d,props:{},children:[{type:a,value:j}]},{type:a,value:"使用其\"代理对象\"(Delegation object)来管理其子视图控制器的显示。"},{type:b,tag:i,props:{href:ar,rel:[p,q,r],target:s},children:[{type:a,value:"具体参考此处:UISplit​View​Controller​Delegate"}]}]},{type:a,value:c},{type:b,tag:u,props:{id:Y},children:[{type:b,tag:i,props:{href:"#configuring-the-appearance-of-the-split-view-interface",ariaHidden:k,tabIndex:l},children:[{type:b,tag:e,props:{className:[m,n]},children:[]}]},{type:a,value:Z}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"split​View​Controller显示的视图配置由当前显示模式("},{type:b,tag:d,props:{},children:[{type:a,value:x}]},{type:a,value:")决定。 配置displayMode需要用到"},{type:b,tag:d,props:{},children:[{type:a,value:as}]},{type:a,value:"属性。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:v,props:{alt:"20170405341751.png",src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F20170405341751.png"},children:[]}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"分割视图控制器尽力尊重您指定的显示模式，但由于空间限制，可能无法视觉上适应该模式。 例如，分割视图控制器不能在水平紧凑的环境中并排显示其子视图控制器。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"下面列出了可用的显示模式，并描述了视图控制器如何布置在屏幕上。 该表还列出了用于请求指定显示模式的常量。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:v,props:{alt:"20170405758942.png",src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F20170405758942.png"},children:[]}]},{type:a,value:c},{type:b,tag:"ul",props:{},children:[{type:a,value:c},{type:b,tag:J,props:{},children:[{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"Side-by-side"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"同时显示全部控制器。主视图控制器显示在左侧，通常比次视图控制器更窄。可以使用"},{type:b,tag:i,props:{href:"https:\u002F\u002Fdeveloper.apple.com\u002Freference\u002Fuikit\u002Fuisplitviewcontroller\u002F1623183-preferredprimarycolumnwidthfract",rel:[p,q,r],target:s},children:[{type:a,value:"preferred​Primary​Column​Width​Fraction"}]},{type:a,value:"属性来控制宽度.\n当"},{type:b,tag:d,props:{},children:[{type:a,value:"is​Collapsed"}]},{type:a,value:"属性为true的时候，这个模式不会显示。在折叠的界面(collapsed interface)时,一次只能看到一个试图控制器。\n这个模式由枚举中"},{type:b,tag:d,props:{},children:[{type:a,value:"all​Visible"}]},{type:a,value:"表示。"},{type:b,tag:"br",props:{},children:[]},{type:a,value:c},{type:b,tag:v,props:{src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F201704066616612.png",width:K},children:[]}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:J,props:{},children:[{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"Hidden:"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"次视图控制器显示在屏幕上，主视图控制器处于关闭屏幕。\n要显示主视图控制器，您必须以模态显示(present it modally)或更改显示模式(change the display mode)。\n该模式由枚举中的"},{type:b,tag:d,props:{},children:[{type:a,value:"primary​Hidden"}]},{type:a,value:at},{type:b,tag:v,props:{src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F20170406785313.png",width:K},children:[]}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:J,props:{},children:[{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"Overlay"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"次视图控制器在屏幕上，主视图控制器分层在其上。 在此模式下，主视图控制器部分地遮挡了次视图控制器(如下图:右侧的控制器一部分被遮挡了)。\n此模式由"},{type:b,tag:d,props:{},children:[{type:a,value:"primary​Overlay"}]},{type:a,value:at},{type:b,tag:v,props:{src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F201704064464314.png",width:K},children:[]}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"当设置完"},{type:b,tag:d,props:{},children:[{type:a,value:as}]},{type:a,value:"后,split​View​Controller会自动更新,并在"},{type:b,tag:d,props:{},children:[{type:a,value:x}]},{type:a,value:"属性中反映实际的显示模式。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"您可以随时更改首选显示模式，这样做会导致split​View​Controller相应地进行自我调整 。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"分割视图控制器还安装内置手势识别器，让用户使用滑动来更改显示模式。您可以通过将"},{type:b,tag:d,props:{},children:[{type:a,value:"presentsWithGesture"}]},{type:a,value:"属性设置为false来抑制此手势识别器。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:v,props:{alt:"2017040669931.png",src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F2017040669931.png"},children:[]}]},{type:a,value:c},{type:b,tag:L,props:{id:"displaymodebuttonitem"},children:[{type:b,tag:i,props:{href:"#displaymodebuttonitem",ariaHidden:k,tabIndex:l},children:[{type:b,tag:e,props:{className:[m,n]},children:[]}]},{type:a,value:au}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:d,props:{},children:[{type:a,value:au}]},{type:a,value:"方法返回一个特殊的"},{type:b,tag:d,props:{},children:[{type:a,value:av}]},{type:a,value:",用于改变"},{type:b,tag:d,props:{},children:[{type:a,value:x}]},{type:a,value:",你可以将其包含在应用程序的用户界面中。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:v,props:{alt:"2017040666102.png",src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F2017040666102.png"},children:[]},{type:a,value:"\n你需要做的是将这个"},{type:b,tag:d,props:{},children:[{type:a,value:av}]},{type:a,value:"添加到界面中相应的"},{type:b,tag:d,props:{},children:[{type:a,value:"navigation bar"}]},{type:a,value:ap},{type:b,tag:d,props:{},children:[{type:a,value:"toolbar"}]},{type:a,value:D}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"当它点击被的时候,按钮会向splitViewController发送一个消息,告诉它改变当前的"},{type:b,tag:d,props:{},children:[{type:a,value:x}]},{type:a,value:D}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"关于改变的结果取决于代理方法中的"},{type:b,tag:d,props:{},children:[{type:a,value:"target​Display​Mode​For​Action(in:​)"}]},{type:a,value:"方法(ps: Objctve-C中对应"},{type:b,tag:d,props:{},children:[{type:a,value:"targetDisplayModeForActionInSplitViewController:"}]},{type:a,value:")。次方法缺省值的为"},{type:b,tag:d,props:{},children:[{type:a,value:"Automatic"}]}]},{type:a,value:c},{type:b,tag:"div",props:{className:["nuxt-content-highlight"]},children:[{type:b,tag:"pre",props:{className:["language-objc","line-numbers"]},children:[{type:b,tag:d,props:{},children:[{type:b,tag:e,props:{className:[g,y]},children:[{type:a,value:"\u002F\u002F设置举例"}]},{type:a,value:"\n "},{type:b,tag:e,props:{className:[g,y]},children:[{type:a,value:"\u002F\u002F Called by the gesture AND barButtonItem to determine what they will set the display mode to (and what the displayModeButtonItem's appearance will be.) Return UISplitViewControllerDisplayModeAutomatic to get the default behavior."}]},{type:a,value:c},{type:b,tag:e,props:{className:[g,E]},children:[{type:a,value:"-"}]},{type:a,value:w},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:F}]},{type:a,value:"UISplitViewControllerDisplayMode"},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:G}]},{type:a,value:"targetDisplayModeForActionInSplitViewController"},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:":"}]},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:F}]},{type:a,value:"UISplitViewController "},{type:b,tag:e,props:{className:[g,E]},children:[{type:a,value:"*"}]},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:G}]},{type:a,value:"svc "},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:H}]},{type:a,value:"\n    \n    "},{type:b,tag:e,props:{className:[g,o]},children:[{type:a,value:aw}]},{type:a,value:w},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:F}]},{type:b,tag:e,props:{className:[g,o]},children:[{type:a,value:ax}]},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:M}]},{type:a,value:ay},{type:b,tag:e,props:{className:[g,E]},children:[{type:a,value:az}]},{type:a,value:N},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:G}]},{type:a,value:w},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:H}]},{type:a,value:O},{type:b,tag:e,props:{className:[g,o]},children:[{type:a,value:P}]},{type:a,value:aA},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:Q}]},{type:a,value:z},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:I}]},{type:b,tag:e,props:{className:[g,o]},children:[{type:a,value:aB}]},{type:a,value:w},{type:b,tag:e,props:{className:[g,o]},children:[{type:a,value:aw}]},{type:a,value:w},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:F}]},{type:b,tag:e,props:{className:[g,o]},children:[{type:a,value:ax}]},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:M}]},{type:a,value:ay},{type:b,tag:e,props:{className:[g,E]},children:[{type:a,value:az}]},{type:a,value:aA},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:G}]},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:H}]},{type:a,value:O},{type:b,tag:e,props:{className:[g,o]},children:[{type:a,value:P}]},{type:a,value:N},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:Q}]},{type:a,value:z},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:I}]},{type:b,tag:e,props:{className:[g,o]},children:[{type:a,value:aB}]},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:H}]},{type:a,value:w},{type:b,tag:e,props:{className:[g,y]},children:[{type:a,value:"\u002F\u002FUISplitViewControllerDisplayModePrimaryOverlay"}]},{type:a,value:O},{type:b,tag:e,props:{className:[g,o]},children:[{type:a,value:P}]},{type:a,value:N},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:Q}]},{type:a,value:z},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:I}]},{type:a,value:z},{type:b,tag:e,props:{className:[g,y]},children:[{type:a,value:"\u002F\u002F这个是缺省值。 默认: 展开为`Overlay`. 隐藏为`Hidden`"}]},{type:a,value:z},{type:b,tag:e,props:{className:[g,y]},children:[{type:a,value:"\u002F\u002Freturn UISplitViewControllerDisplayModeAutomatic;"}]},{type:a,value:c},{type:b,tag:e,props:{className:[g,h]},children:[{type:a,value:I}]},{type:a,value:c}]}]}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"上述代理如果设置返回的是"},{type:b,tag:d,props:{},children:[{type:a,value:"UISplitViewControllerDisplayModeAutomatic"}]},{type:a,value:"或者干脆没实现这个代理方法,视图控制器会根据当前屏幕大小选择合适的模式。 例如，在竖屏的iPad上，控制器在hidden和overlay模式之间切换。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"切换模式也可以通过手势来进行，手势也可以通过代理方法来确定要使用的显示模式。"}]},{type:a,value:c},{type:b,tag:u,props:{id:_},children:[{type:b,tag:i,props:{href:"#changing-child-view-controllers-in-a-split-view-interface%EF%BC%88%E6%94%B9%E5%8F%98%E5%AD%90%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%89",ariaHidden:k,tabIndex:l},children:[{type:b,tag:e,props:{className:[m,n]},children:[]}]},{type:a,value:$}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"当设计一个splitViewController的时候，当然如果主视图和辅助视图都不改变是最好的。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"常见的技术是在主视图和辅助视图都是导航控制器(navigationController)控制的,然后可以根据实际的需要进行控制器的"},{type:b,tag:d,props:{},children:[{type:a,value:ao}]},{type:a,value:"或者"},{type:b,tag:d,props:{},children:[{type:a,value:aq}]},{type:a,value:"操作."}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"如果需要"},{type:b,tag:"em",props:{},children:[{type:b,tag:"strong",props:{},children:[{type:a,value:"更改主视图控制器或辅助视图控制器"}]}]},{type:a,value:"，建议您使用"},{type:b,tag:d,props:{},children:[{type:a,value:"show(_:​sender:​)"}]},{type:a,value:R},{type:b,tag:d,props:{},children:[{type:a,value:aC}]},{type:a,value:" 方法。使用这些方法（而不是直接修改"},{type:b,tag:d,props:{},children:[{type:a,value:"controllers"}]},{type:a,value:"属性）使分割视图控制器以最适合当前显示模式和size class的方式呈现指定的视图控制器。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"splitViewController知道如何以更直观的方式调整界面。它甚至可以与其他容器视图控制器（如导航控制器）一起使用来呈现视图控制器。举个有点特殊的例子,在比较紧凑("},{type:b,tag:d,props:{},children:[{type:a,value:A}]},{type:a,value:")的环境中(比如iPhone 6plus的横屏状态),开始显示的控制器A(辅助视图)是一个导航控制器。这时候调用"},{type:b,tag:d,props:{},children:[{type:a,value:aC}]},{type:a,value:"方法并不会替换掉视图控制器A。相反，视图控制器A将目标控制器push到其导航堆栈。"}]},{type:a,value:c},{type:b,tag:u,props:{id:aa},children:[{type:b,tag:i,props:{href:"#collapsing-and-expanding-the-split-view-interface",ariaHidden:k,tabIndex:l},children:[{type:b,tag:e,props:{className:[m,n]},children:[]}]},{type:a,value:ab}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"splitViewController进行展开和收齐的时候,它的"},{type:b,tag:d,props:{},children:[{type:a,value:"size class"}]},{type:a,value:"在水平方向的"},{type:b,tag:d,props:{},children:[{type:a,value:S}]},{type:a,value:R},{type:b,tag:d,props:{},children:[{type:a,value:A}]},{type:a,value:"间切换。 在切换过程中,splitViewController会改变子视图控制器的显示方式."}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"当从水平方向"},{type:b,tag:d,props:{},children:[{type:a,value:S}]},{type:a,value:aD},{type:b,tag:d,props:{},children:[{type:a,value:A}]},{type:a,value:"时,splitViewController”收起“后显示一个控制器。\n当从水平方向"},{type:b,tag:d,props:{},children:[{type:a,value:A}]},{type:a,value:aD},{type:b,tag:d,props:{},children:[{type:a,value:S}]},{type:a,value:"时,splitViewController会根据设定的"},{type:b,tag:d,props:{},children:[{type:a,value:x}]},{type:a,value:"屏幕”展开“显示一个或多个控制器."}]},{type:a,value:c},{type:b,tag:L,props:{id:"收起-（collapsing-process）"},children:[{type:b,tag:i,props:{href:"#%E6%94%B6%E8%B5%B7-%EF%BC%88collapsing-process%EF%BC%89",ariaHidden:k,tabIndex:l},children:[{type:b,tag:e,props:{className:[m,n]},children:[]}]},{type:a,value:"收起 （collapsing process）"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"当界面转换到“收起\"时，分割视图控制器与其代理一起管理转换。在”收起“结束时,splitViewController通常只显示主视图控制器了。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"你可以在代理中实现"},{type:b,tag:d,props:{},children:[{type:a,value:"primary​View​Controller(for​Collapsing:​)"}]},{type:a,value:"方法来变此行为。您可以使用该方法来指定次视图控制器或完全不同的视图控制器 - 也许那个控制器更适合在水平方向"},{type:b,tag:d,props:{},children:[{type:a,value:A}]},{type:a,value:"的环境中显示。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"如果相对控制器和视图层次进行额外调整,你可以在代理中实现"},{type:b,tag:d,props:{},children:[{type:a,value:"split​View​Controller(_:​collapse​Secondary:​onto:​)"}]},{type:a,value:aE}]},{type:a,value:c},{type:b,tag:L,props:{id:"展开--（expansion-process）"},children:[{type:b,tag:i,props:{href:"#%E5%B1%95%E5%BC%80--%EF%BC%88expansion-process%EF%BC%89",ariaHidden:k,tabIndex:l},children:[{type:b,tag:e,props:{className:[m,n]},children:[]}]},{type:a,value:"展开  （expansion process）"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"展开是收起的相反的过程。这一过程会询问delegate哪个控制器将成为主视图控制器(primary view controller)并且提供给delegate机会去执行transition变换。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"如果你实现了\"收起\"的代理方法，那么同样你也应该为\"展开\"实现"},{type:b,tag:d,props:{},children:[{type:a,value:"primary​View​Controller(for​Expanding:​)"}]},{type:a,value:R},{type:b,tag:d,props:{},children:[{type:a,value:"split​View​Controller(_:​separate​Secondary​From:​)"}]},{type:a,value:aE}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"如果没实现“收起”和“展开”的任何代理方法,那也没关系。splitViewController提供了收起\u002F展开的缺省值。"}]},{type:a,value:c},{type:b,tag:aF,props:{},children:[]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"关于收起(collapse)、展开(expand)的更多信息,请查看"},{type:b,tag:i,props:{href:ar,rel:[p,q,r],target:s},children:[{type:a,value:"UISplit​View​Controller​Delegate"}]},{type:a,value:M}]},{type:a,value:c},{type:b,tag:u,props:{id:ac},children:[{type:b,tag:i,props:{href:"#message-forwarding-to-its-child-view-controllers",ariaHidden:k,tabIndex:l},children:[{type:b,tag:e,props:{className:[m,n]},children:[]}]},{type:a,value:ad}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"splitViewController对window和子控制器(child view controllers)进行了协调。 因此所有到子控制的所有消息都会流经splitViewController.\n这通常可以预期，消息的流程应该比较直观。 例如，仅当相应的子视图控制器实际出现在屏幕上时才会发送查看外观显示或消失的消息。"}]},{type:a,value:c},{type:b,tag:u,props:{id:ae},children:[{type:b,tag:i,props:{href:"#state-preservation",ariaHidden:k,tabIndex:l},children:[{type:b,tag:e,props:{className:[m,n]},children:[]}]},{type:a,value:af}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"在iOS6或者更高版本上,如果你给定了splitViewController的"},{type:b,tag:i,props:{href:"https:\u002F\u002Fdeveloper.apple.com\u002Freference\u002Fuikit\u002Fuiviewcontroller\u002F1621499-restorationidentifier",rel:[p,q,r],target:s},children:[{type:a,value:"restoration​Identifier"}]},{type:a,value:"属性值。 那么它将会保存具有有效恢复标识符(valid restoration identifier)的所有子控制器。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"在程序下一次启动时,splitViewController将会回复到之前的状态。splitViewController的子视图控制器可以使用相同的恢复标识符。splitViewController自动存储附加信息，以确保每个子控制器的恢复路径是唯一的。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"有关状态保存和恢复的工作原理的更多信息，请参阅"},{type:b,tag:i,props:{href:"https:\u002F\u002Fdeveloper.apple.com\u002Flibrary\u002Fcontent\u002Fdocumentation\u002FiPhone\u002FConceptual\u002FiPhoneOSProgrammingGuide\u002FIntroduction\u002FIntroduction.html#\u002F\u002Fapple_ref\u002Fdoc\u002Fuid\u002FTP40007072",rel:[p,q,r],target:s},children:[{type:a,value:"App Programming Guide for iOS"}]},{type:a,value:D}]},{type:a,value:c},{type:b,tag:aF,props:{},children:[]},{type:a,value:c},{type:b,tag:an,props:{},children:[{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"参考内容\n"},{type:b,tag:i,props:{href:aG,rel:[p,q,r],target:s},children:[{type:a,value:aG}]},{type:a,value:c},{type:b,tag:i,props:{href:aH,rel:[p,q,r],target:s},children:[{type:a,value:aH}]}]},{type:a,value:c}]}]},excerpt:{type:ag,children:[{type:b,tag:f,props:{},children:[{type:a,value:ah},{type:b,tag:d,props:{},children:[{type:a,value:C}]},{type:a,value:ai},{type:b,tag:d,props:{},children:[{type:a,value:j}]},{type:a,value:aj}]}]},dir:"\u002Fwiki\u002FiOS\u002FUIKit",path:aI,extension:".md",createdAt:aJ,updatedAt:aJ},prev:{slug:aK,title:aL,date:aM},next:{slug:aN,title:aO,date:aP},scrollTop:aQ,sideCategory:[{folderName:"iOS",articles:[{slug:"iOS-Swift-ObjectMapper 指南",title:"Swift-ObjectMapper 指南",date:"2016-05-23 16:13",path:"\u002Fwiki\u002FiOS\u002FiOS-Swift-ObjectMapper 指南"},{slug:"iOS-URL Schemes && Universal Links 简单使用",title:"URL Schemes && Universal Links 简单使用",date:"2017-02-14T00:00:00.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-URL Schemes && Universal Links 简单使用"},{slug:"iOS-YYModel",title:"YYModel几种使用场景",date:aR,path:"\u002Fwiki\u002FiOS\u002FiOS-YYModel"},{slug:"iOS-ios-useful-link",title:"'实用链接",date:"2017-07-14T16:58:04.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-ios-useful-link"},{slug:"iOS-mrpeak杂货铺-iOS应用层架构之CDD",title:"(转)mrpeak杂货铺-iOS应用层架构之CDD",date:aS,path:"\u002Fwiki\u002FiOS\u002FiOS-mrpeak杂货铺-iOS应用层架构之CDD"},{slug:"iOS-检测离屏渲染与绘制高性能圆角",title:"(待)检测离屏渲染与绘制高性能圆角",date:"2017-08-17T10:03:56.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-检测离屏渲染与绘制高性能圆角"},{slug:"iOS-深度重构UIViewController",title:"(转)mrpeak杂货铺-深度重构UIViewController",date:"2017-11-19T21:33:42.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-深度重构UIViewController"},{slug:"iOS-添加字体库",title:"使用第三方字体",date:aS,path:"\u002Fwiki\u002FiOS\u002FiOS-添加字体库"}],children:[{folderName:"3part",articles:[{slug:"3part-umeng-install",title:"快速集成友盟分享",date:"2018-03-01 16:11",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-umeng-install"},{slug:"3part-快速集成微信支付",title:"快速集成微信\u002F支付宝\u002F银联",date:"2017-11-17T16:19:25.000Z",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-快速集成微信支付"},{slug:"3part-快速集成百度地图",title:"集成百度地图、百度导航",date:"2017-08-11T11:24:43.000Z",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-快速集成百度地图"},{slug:"3part-阿里云视频点播集成",date:"2020-10-26T01:10:15.000Z",title:"阿里云视频点播VOD",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-阿里云视频点播集成"}],children:[]},{folderName:"Autolayout",articles:[{slug:"Autolayout-baseline",title:"label底部对齐、顶部对齐",date:aT,path:"\u002Fwiki\u002FiOS\u002FAutolayout\u002FAutolayout-baseline"}],children:[]},{folderName:"Error",articles:[{slug:"Error-2017-07-31",title:"Undefined symbols for architecture ..",date:"2017-07-31T08:52:40.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-2017-07-31"},{slug:"Error-Shell-Script-Invocation-Error",title:"'Shell Script Invocation Error'",date:"2017-07-20T14:27:04.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-Shell-Script-Invocation-Error"},{slug:"Error-gesture",title:"tableViewCell的点击和tapGestureRecognizer冲突的处理",date:"2016-11-19T21:33:42.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-gesture"},{slug:"Error-崩溃分析",date:"2020-11-11T07:28:34.000Z",title:"崩溃分析(转载)",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-崩溃分析"},{slug:"Error-竖屏下视频全屏播放",title:"(转)竖屏下视频全屏播放",date:"2017-08-01T15:23:01.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-竖屏下视频全屏播放"},{slug:"Error-证书过期或者移除对app的影响",title:"证书过期或者移除对app的影响",date:"2018-01-11T13:49:33.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-证书过期或者移除对app的影响"}],children:[]},{folderName:"Objective-C",articles:[{slug:"Objective-C-KVO - Observe property of an object contained in a NSArray",title:"KVO - Observe property of an object contained in a NSArray",date:"2017-09-28 22:26",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-KVO - Observe property of an object contained in a NSArray"},{slug:"Objective-C-NSArrayFilter",title:"NSArray: filteredArrayUsingPredicate",date:"2017-09-14 16:24",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-NSArrayFilter"},{slug:"Objective-C-NSRecursiveLock",date:"2020-10-27T00:52:16.000Z",title:"NSRecursiveLock",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-NSRecursiveLock"},{slug:"Objective-C-NSStringCompareOptions",title:"NSStringCompareOptions",date:"2017-07-10T17:13:25.000Z",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-NSStringCompareOptions"},{slug:"Objective-C-containsObject-or-removeObject",title:"containsObject or removeObject",date:"2015年04月12日09:55:35",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-containsObject-or-removeObject"},{slug:"Objective-C-get-lunarholidays",title:"节气、节假日计算",date:"2017-07-13T09:30:26.000Z",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-get-lunarholidays"},{slug:"Objective-C-use-dispatch_queue_t-with-strong",title:"dispatch_queue_t 用strong来修饰",date:aR,path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-use-dispatch_queue_t-with-strong"},{slug:"Objective-C-农历",title:"农历",date:"2017-07-11T13:12:46.000Z",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-农历"},{slug:"Objective-C-常用的宏",title:"常用的宏",date:"2015-03-04 11:11",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-常用的宏"}],children:[]},{folderName:"StatusBar",articles:[{slug:"StatusBar-how-to-detect-touches-in-status-bar",title:"获取StatusBar的点击事件",date:aU,path:"\u002Fwiki\u002FiOS\u002FStatusBar\u002FStatusBar-how-to-detect-touches-in-status-bar"},{slug:"StatusBar-ios-status-bar-style",title:"修改StatusBarStyle以及statusBar的背景颜色",date:aU,path:"\u002Fwiki\u002FiOS\u002FStatusBar\u002FStatusBar-ios-status-bar-style"}],children:[]},{folderName:"UIKit",articles:[{slug:"UIKit-UIAlertController修改文字对齐方式",date:"2020-10-23T08:07:07.000Z",title:"UIAlertController修改文字对齐方式",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-UIAlertController修改文字对齐方式"},{slug:"UIKit-UIDynamic Animator",title:"UIDynamic Animator",date:"2016-07-20T16:13:11.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-UIDynamic Animator"},{slug:T,title:U,date:V,path:aI},{slug:"UIKit-searchBar-style",title:"如何修改searchBar的样式",date:"2017-05-14T19:01:01.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-searchBar-style"},{slug:"UIKit-uioffset",title:"UIOffset",date:"2017-08-02T15:30:01.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-uioffset"},{slug:"UIKit-屏幕旋转.md",date:"2020-11-09T06:04:42.000Z",title:"屏幕旋转",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-屏幕旋转.md"},{slug:"UIKit-离屏渲染",title:"(转)关于iOS离屏渲染的深入研究",date:"2020-04-06T00:00:00.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-离屏渲染"},{slug:aK,title:aL,date:aM,path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-给WebView添加个粗糙的加载动画"}],children:[]},{folderName:"UITextFeild",articles:[{slug:"UITextFeild-2018-01-16",title:"修改光标颜色和clear button的颜色",date:"2018-01-16T15:44:44.000Z",path:"\u002Fwiki\u002FiOS\u002FUITextFeild\u002FUITextFeild-2018-01-16"},{slug:"UITextFeild-uitextfeild-select-all",title:"默认选中文本",date:"2017-07-07 04:44",path:"\u002Fwiki\u002FiOS\u002FUITextFeild\u002FUITextFeild-uitextfeild-select-all"}],children:[]},{folderName:"keyboard",articles:[{slug:"keyboard-disable-3rd-keyboard",title:"禁用第三方键盘",date:aT,path:"\u002Fwiki\u002FiOS\u002Fkeyboard\u002Fkeyboard-disable-3rd-keyboard"}],children:[]},{folderName:"loc",articles:[{slug:"loc-2018-01-22",title:"CLPlacemark中文",date:"2018-01-22T14:36:49.000Z",path:"\u002Fwiki\u002FiOS\u002Floc\u002Floc-2018-01-22"},{slug:"loc-sim-locaiton-ios",title:"真机或模拟器修改定位位置",date:"2017-08-11T10:29:01.000Z",path:"\u002Fwiki\u002FiOS\u002Floc\u002Floc-sim-locaiton-ios"}],children:[]},{folderName:"tableView",articles:[{slug:"tableView-cell-seprateLine",title:"cell分割线的颜色",date:"2017-08-08T15:26:14.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-cell-seprateLine"},{slug:"tableView-compare-NSIndexPath",title:"compare NSIndexPath",date:"2017-08-15T17:01:49.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-compare-NSIndexPath"},{slug:aN,title:aO,date:aP,path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-tabeleView 获取某个cell的高度"},{slug:"tableView-taleview-headerfooterView-xib",title:"xib UITableViewHeaderFooterView",date:"2017-08-18T09:47:36.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-taleview-headerfooterView-xib"},{slug:"tableView-结合layoutMargins做tableViewCell的适配",title:"结合layoutMargins做cell的适配",date:"2017-08-20T21:55:52.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-结合layoutMargins做tableViewCell的适配"}],children:[]},{folderName:"xib",articles:[{slug:"xib-如何替换已有的控件",title:"如何替换已有的控件",date:"2017-09-07T10:51:38.000Z",path:"\u002Fwiki\u002FiOS\u002Fxib\u002Fxib-如何替换已有的控件"}],children:[]},{folderName:"代码片段",articles:[{slug:"代码片段-分割小说章节",title:"分割小说章节",date:"2017-01-18T15:12:12.000Z",path:"\u002Fwiki\u002FiOS\u002F代码片段\u002F代码片段-分割小说章节"},{slug:"代码片段-截图 截长图 高清图",title:"截图 截长图 高清图",date:"2016-05-04 22:38",path:"\u002Fwiki\u002FiOS\u002F代码片段\u002F代码片段-截图 截长图 高清图"},{slug:"代码片段-读取未知类型的txt文件",title:"读取未知类型的txt文件 ",date:"2017-01-16 20:12",path:"\u002Fwiki\u002FiOS\u002F代码片段\u002F代码片段-读取未知类型的txt文件"}],children:[]},{folderName:"包管理工具",articles:[{slug:"包管理工具-spm-resource-handle",date:"2020-11-19T00:58:59.000Z",title:"SWift Package Manager资源文件管理",path:"\u002Fwiki\u002FiOS\u002F包管理工具\u002F包管理工具-spm-resource-handle"},{slug:"包管理工具-spm-introduce",date:"2020-11-18T08:08:33.000Z",title:"Swift Package Manager介绍",path:"\u002Fwiki\u002FiOS\u002F包管理工具\u002F包管理工具-spm-introduce"}],children:[]},{folderName:"日历",articles:[{slug:"日历-FSCalendar",title:"FSCalendar",date:"2017-07-11T08:48:12.000Z",path:"\u002Fwiki\u002FiOS\u002F日历\u002F日历-FSCalendar"}],children:[]},{folderName:"适配",articles:[{slug:"适配-NFC初试",title:"NFC初试",date:"2017-06-07 18:31",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-NFC初试"},{slug:"适配-iOS11 Xcode9新功能新特性",title:"iOS11 Xcode9新功能新特性",date:aV,path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11 Xcode9新功能新特性"},{slug:"适配-iOS11 tableView适配不完全指南",title:"iOS11 tableView适配不完全指南",date:"2017-09-19 12:33",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11 tableView适配不完全指南"},{slug:"适配-iOS11刘海屏EdgeProtect相关",date:"2020-10-26T06:00:25.000Z",title:"iOS11刘海屏EdgeProtect相关",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11刘海屏EdgeProtect相关"},{slug:"适配-iOS11适配参考",title:"iOS11 适配参考",date:aV,path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11适配参考"},{slug:"适配-iOS14hidesBottomBarWhenPushed兼容问题",date:"2020-10-23T08:53:49.000Z",title:"iOS14 hidesBottomBarWhenPushed兼容问题",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS14hidesBottomBarWhenPushed兼容问题"},{slug:"适配-touch-id",title:"touch Id",date:"2017-08-04T13:46:10.000Z",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-touch-id"}],children:[]},{folderName:"问与答",articles:[{slug:"问与答-为什么ui操作要在主线程",date:"2020-11-16T03:38:48.000Z",title:"为什么ui操作要在主线程",path:"\u002Fwiki\u002FiOS\u002F问与答\u002F问与答-为什么ui操作要在主线程"}],children:[]}]}]}],fetch:{},mutations:aQ}}("text","element","\n","code","span","p","token","punctuation","a","split​View​Controller","true",-1,"icon","icon-link","keyword","nofollow","noopener","noreferrer","_blank",2,"h2","img"," ","displayMode","comment","\n    ","compact","介绍","UISplitViewController","。","operator","(",")","{","}","li","400px","h4","."," UISplitViewControllerDisplayModePrimaryHidden","\n        \n        ","return",";","和","regular","UIKit-UISplit​View​Controller 学习笔记","UISplit​View​Controller 学习笔记","2017-04-07T00:00:00.000Z","overview","Overview","configuring-the-appearance-of-the-split-view-interface","Configuring the Appearance of the Split View Interface","changing-child-view-controllers-in-a-split-view-interface（改变子视图控制器）","Changing Child View Controllers in a Split View Interface（改变子视图控制器）","collapsing-and-expanding-the-split-view-interface","Collapsing and Expanding the Split View Interface","message-forwarding-to-its-child-view-controllers","Message Forwarding to Its Child View Controllers","state-preservation","State Preservation","root","个人感觉","是比较鸡肋的东西,开发中自定义","的时候比较常见。","master-detail","master","detail","blockquote","push","或","pop","https:\u002F\u002Fdeveloper.apple.com\u002Freference\u002Fuikit\u002Fuisplitviewcontrollerdelegate","preferredDisplayMode","表示。\n","display​Mode​Button​Item","barButtonItem","if","self","displayMode ","=="," UISplitViewControllerDisplayModeAllVisible","else","show​Detail​View​Controller(_:​sender:​)","转换到","方法。","hr","https:\u002F\u002Fdeveloper.apple.com\u002Freference\u002Fuikit\u002Fuisplitviewcontroller","http:\u002F\u002Fnshipster.cn\u002Fuisplitviewcontroller\u002F","\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-UISplit​View​Controller 学习笔记","2021-08-24T05:56:45.924Z","UIKit-给WebView添加个粗糙的加载动画","给UIWebView添加个粗糙的加载动画","2017-02-10T00:00:00.000Z","tableView-tabeleView 获取某个cell的高度","tabeleView 获取某个cell的高度","2017-05-09T10:36:29.000Z",void 0,"2017-08-31T09:32:08.000Z","2017-10-27T18:01:13.000Z","2017-08-19T16:10:51.000Z","2016-07-01T14:19:23.000Z","2017-09-20T15:20:33.000Z")));
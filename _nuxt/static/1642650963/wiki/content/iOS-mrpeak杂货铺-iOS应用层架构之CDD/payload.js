__NUXT_JSONP__("/wiki/content/iOS-mrpeak%E6%9D%82%E8%B4%A7%E9%93%BA-iOS%E5%BA%94%E7%94%A8%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B9%8BCDD", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R){return {data:[{},{article:{slug:w,title:x,layout:"page",date:s,toc:[{id:y,depth:t,text:z},{id:A,depth:t,text:B},{id:C,depth:t,text:D},{id:E,depth:t,text:F}],body:{type:"root",children:[{type:b,tag:"blockquote",props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"原文地址 "},{type:b,tag:f,props:{href:G,rel:[g,h,i],target:j},children:[{type:a,value:G}]}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:"h1",props:{id:"cdd"},children:[{type:b,tag:f,props:{href:"#cdd",ariaHidden:m,tabIndex:n},children:[{type:b,tag:o,props:{className:[p,q]},children:[]}]},{type:a,value:"CDD"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"从2010年开始接触iOS开发到现在，折腾过不少app的架构。从"},{type:b,tag:f,props:{href:"https:\u002F\u002Fdeveloper.apple.com\u002Flibrary\u002Fios\u002Fdocumentation\u002FGeneral\u002FConceptual\u002FDevPedia-CocoaCore\u002FMVC.html",rel:[g,h,i],target:j},children:[{type:a,value:"MVC"}]},{type:a,value:"到"},{type:b,tag:f,props:{href:"https:\u002F\u002Fwww.objc.io\u002Fissues\u002F13-architecture\u002Fmvvm\u002F",rel:[g,h,i],target:j},children:[{type:a,value:"MVVM"}]},{type:a,value:v},{type:b,tag:f,props:{href:"https:\u002F\u002Fwww.objc.io\u002Fissues\u002F13-architecture\u002Fviper\u002F",rel:[g,h,i],target:j},children:[{type:a,value:"VIPER"}]},{type:a,value:v},{type:b,tag:f,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FModel%E2%80%93view%E2%80%93presenter",rel:[g,h,i],target:j},children:[{type:a,value:"MVP"}]},{type:a,value:"，以及最新的"},{type:b,tag:f,props:{href:"https:\u002F\u002Fgithub.com\u002FReactiveCocoa\u002FReactiveCocoa",rel:[g,h,i],target:j},children:[{type:a,value:"ReactiveCocoa"}]},{type:a,value:"都做过实战尝试，还有其他变种，诸如"},{type:b,tag:f,props:{href:"http:\u002F\u002Fmp.weixin.qq.com\u002Fs?__biz=MjM5NTIyNTUyMQ==&mid=444322139&idx=1&sn=c7bef4d439f46ee539aa76d612023d43&scene=0#wechat_redirect",rel:[g,h,i],target:j},children:[{type:a,value:"猿题库iOS客户端架构设计"}]},{type:a,value:"，也做过一些学习研究。这些技术概念如果不熟悉，建议每个链接都点开好好研读下，不要对你的大脑太温柔。在开始架构讨论之前，再推荐一些其他非常值得一读的文章："},{type:b,tag:f,props:{href:"http:\u002F\u002Fmp.weixin.qq.com\u002Fs?__biz=MjM5NTIyNTUyMQ==&mid=407454565&idx=1&sn=f2c207e30f700219d5811371b34b8cf9&scene=21#wechat_redirect",rel:[g,h,i],target:j},children:[{type:a,value:"唐巧－被误解的 MVC 和被神化的 MVVM"}]},{type:a,value:"， "},{type:b,tag:f,props:{href:"http:\u002F\u002Fcasatwy.com\u002Fiosying-yong-jia-gou-tan-kai-pian.html",rel:[g,h,i],target:j},children:[{type:a,value:"Casa Taloyum iOS架构系列文章"}]},{type:a,value:v},{type:b,tag:f,props:{href:"https:\u002F\u002Fwww.objc.io\u002Fissues\u002F13-architecture\u002F",rel:[g,h,i],target:j},children:[{type:a,value:"objc.io架构系列文章"}]},{type:a,value:H}]},{type:a,value:c},{type:b,tag:u,props:{id:y},children:[{type:b,tag:f,props:{href:"#1%E5%BA%94%E7%94%A8%E5%B1%82%E6%9E%B6%E6%9E%84%E5%AE%9A%E4%B9%89",ariaHidden:m,tabIndex:n},children:[{type:b,tag:o,props:{className:[p,q]},children:[]}]},{type:b,tag:k,props:{},children:[{type:a,value:z}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"其实严格来说，MVC和其他类似概念还算不上一个完整的架构。一个颇具规模的app必然会涉及到分层的设计，还有模块化，hybrid机制，热补丁等等。MVC这种更像是个设计模式，解决的只是app分层设计当中的应用层（Applicaiton Layer）组织方式。对于一些简单app来说，可能应用层一层就完成了整个app的架构，不用担心业务膨胀对后期开发的压力。这里我介绍一种新的应用层架构方式，名之为CDD：Context Driven Design。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"先明确下我们讨论的范畴，什么是一个app的应用层呢？现在不少app都会做一个分层的设计，一般为三层：应用层，service层，data access层。每一层再通过面向接口的方式产生依赖。"}]},{type:a,value:c},{type:b,tag:r,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"应用层是直接和用户打交道的部分，也就是我们常常用到的UIViewController，负责数据的展示，用户交互的处理，数据的采集等等。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"service层位于应用层的下面，为应用层提供公共的服务接口，对应用层来说就像是一个server，不过api调用的延迟为0ms，service层里放哪些代码做法没有统一的规范，一般来说会包含业务数据的处理，网络接口的调用，公共系统服务api封装（比如gps定位，相册，权限控制）等等。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"data access层顾名思义是负责处理我们app的基础数据，api设计规范一般遵循"},{type:b,tag:f,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FCreate,_read,_update_and_delete",rel:[g,h,i],target:j},children:[{type:a,value:"CRUD"}]},{type:a,value:"。这一层位于service层的下方，提供数据库交互所需的api。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"这是基础部分，不同的团队具体做法又会有一些差异。比如有些把data access层又叫做model层，有些把网络模块放在service层，有些则放在data acess层，有些把部分的业务数据放到model里面做成胖model，有些则坚持使用瘦model，把业务代码放在独立的地方统一管理，等等差异不一而足。除了分层还有一些公共模块的设计，比如数据库，网络，安全，热补丁，hybrid机制，性能监测模块，日志模块等等如何配合分层设计，这里就不一一展开了。我们今天讨论的重点在应用层。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"首先严正声明，这个CDD其实是我很久之前看Android代码脑洞出来的\u003E_\u003C||| ，刚好解决了我之前组织应用层代码的一个痛点。做过Android的朋友应该都知道，在很多类里都可以通过getContext方法获取到一个context，再通过这个context可以获取到其他系统资源。当时我第一次了解完这个context概念的时候，瞬间产生了一个这样的脑洞："}]},{type:a,value:c},{type:b,tag:l,props:{src:"http:\u002F\u002Fmrpeak.cn\u002Fimages\u002Fcdd_initial.png",width:594},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"我知道这灵光一闪的脑洞有点大，容我慢慢道来。前面提到应用层其实是在管理一堆UIViewController。拿微信做例子（我真的很喜欢拿微信举个栗子），首页4个tab，4个界面，4个controller，每个controller都有很多UI元素，点击又可以进入二级的controller，各controller可以看成一个独立的模块，有些简单，有些复杂。比如聊天界面这个controller就非常非常的复杂。先来看下聊天界面。"}]},{type:a,value:c},{type:b,tag:l,props:{src:"http:\u002F\u002Fmrpeak.cn\u002Fimages\u002Fcdd_wechat.jpg",width:I},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"这个界面展示的UI元素非常之多，顶部导航栏，消息tableView，输入框部分，功能入口部分，可点击交互的部分也很多。如果我们把所有这些UI元素和交互的处理都放倒Controller里面，我们将得到一个著名的MVC（Massive View Controller），我曾经就有幸维护过一个这样controller，一个类文件一万多行代码，修起bug来十分的酸爽。很显然，我们的目标是拆分代码，所谓的架构不就是“以低耦合的方式分散业务复杂度”嘛。如果我们能把这些UI元素放倒不同的xxxView.m里面，交互的处理也有单独的类，目标达成。但新的问题是这些分散的各个类文件之间怎么交互，怎么耦合，怎么合体。MVC，MVVM，MVP等等都是在解决这个问题。这里我们团结各个类文件的方式是Context！建议再回看下上面的脑洞图。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"在近一步深入讨论CDD之前，我们再重点强调下一个概念，data flow（还有其他别名，info flow，数据流等）。data flow是架构优劣的测量标准，好的架构一定有清晰的data flow，你说你架构怎么好，但data flow说不清楚，No，No，我们不约。什么是data flow，就是数据在你的app里流动的路线，就像人体血管里的血液，滋养着各个器官的运作。上面的聊天界面里，用户在输入框输入一个“hello”文本，文本被你包装成message model，再保存到db，再发送到服务器，最后在界面上展示给用户，这就是一个完整的data flow。实际的data经历的模块会更多，大部分的bug都是data除了问题，修bug时就是在顺着这个flow顺藤摸瓜，把脉诊断。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"再问个问题，什么是data？你可以说data是model，是上面的“hello”文本。但我们还可以站在更高的角度来看待data，data是程序世界的基本元素，另一个基本元素是verb（动作），程序的世界里的所有存在都可以由这两个元素来描述，此处应该双手合十，进入冥想三分钟。推荐一篇"},{type:b,tag:f,props:{href:"http:\u002F\u002Fsteve-yegge.blogspot.com\u002F2006\u002F03\u002Fexecution-in-kingdom-of-nouns.html",rel:[g,h,i],target:j},children:[{type:a,value:"大神吐槽java的文章"}]},{type:a,value:H}]},{type:a,value:c},{type:b,tag:u,props:{id:A},children:[{type:b,tag:f,props:{href:"#2cdd%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3",ariaHidden:m,tabIndex:n},children:[{type:b,tag:o,props:{className:[p,q]},children:[]}]},{type:b,tag:k,props:{},children:[{type:a,value:B}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"接下来进入正题，剖析CDD。我们先把应用层分解成三块任务："}]},{type:a,value:c},{type:b,tag:r,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"UI的展示，UI的展示通过分解UIView可以实现复杂度的分散，UI的变化则可以参考MVVM的方式，通过观察者模式（KVO）来实现。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"业务的处理，业务处理为了方便管理不能分散到不同的类，反而需要放到统一的地方管理，业务代码太分散会给调试带来很大的麻烦。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"data flow，所有数据的变化可以在统一的地方被追踪。数据的流向单一清晰。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"在这三块划分的前提下我们再来制定CDD要达成的目标："}]},{type:a,value:c},{type:b,tag:r,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"view的展示可以被分解成若干个子view.m文件，各自管理。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"业务处理代码放到统一的BusinessObject.m文件来管理。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"model的变化有统一的类DataHandler.m文件来管理。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"UIViewController里面只存放Controller生命周期相关的代码，做成轻量级的Controller。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"所有子view可以处理只和自己相关的逻辑，如果属于整体的业务逻辑，则需要通过context传输到BusinessObject来处理。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"子view展示所需的数据可以通过context获取到，并通过KVO的方式直接进行绑定。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"根据这些目标，我把脑洞图完善下就得到了下面一个更清晰的方案图："}]},{type:a,value:c},{type:b,tag:l,props:{src:"http:\u002F\u002Fmrpeak.cn\u002Fimages\u002Fcdd_update.png",width:804},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"到这里context的作用就很明显了，context可以把所有的子view都连接起来，可以把业务逻辑都导向同一个地方，可以把数据的管理都集中在一个类。所有的类都可以访问到context，但各部分只通过接口产生依赖，将耦合降至最低。至此CDD的大致结构就完成了，但还有一个问题需要解决。view的更新需要跟数据直接绑定，需要做成数据驱动的模式，类似MVVM。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:k,props:{},children:[{type:a,value:"但是我们怎么定义数据的变化呢？"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"做数据驱动的设计就一定要有一套规范去定义数据的变化，在应用层数据的变化我们可以主要分为两类。一是model本身property的变化，这种变化可以用KVO来监听，很方便。另一种是集合类的变化，比如array，set，dictionary等，这类变化又包括元素的增删替换，Objective-C没有提供原生的支持来监听这类变化，所以我们需要自己定一个子类，再通过重载增删替换方法来实现，在Demo中我就定义了一个CDDMutableArray。定义数据的变化十分关键，直接关系到我们怎么去设计data flow。data access层也需要定义一套规范，这里就不展开了。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:k,props:{},children:[{type:a,value:"CDD的data flow是怎样的呢？"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"前面提到了data flow是架构是否清晰的评判标准，是我们debug时的主要依赖。基于上面的讨论CDD的data flow是这样的："}]},{type:a,value:c},{type:b,tag:l,props:{src:"http:\u002F\u002Fmrpeak.cn\u002Fimages\u002Fcdd_flow.png",width:773},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"我之前提到说CDD解决了我之前的一个痛点，其实就是分散复杂度时，需要大量的delegate传递来连接各个类，很多地方都需要引用protocol，比如输入框view产生的“hello”文本要通过delegate传递给superview，superview可能还有superview，再到controller，controller再传递给业务处理的类，最后可能还要通过delegate做回传。但我们看下CDD的整个flow，Controller就像是一个旁观者，根本不需要参与到任何数据的传递，仅仅作为各个对象的持有者，只处理controller本身相关的业务，比如view appear，disappear，rotate等，controller也是context的持有者，也可以在viewWillAppear的时候把事件传递到BusinessObject进行处理。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"输入框view产生的“hello”文本，直接通过context传递到BusinessObject进行处理，生成的新消息message通过DataHandler插入到message array之后，直接通知到message tableview进行刷新。方法调用的路径变短了，意味着调试的时候step over的次数减少了。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"这里有一点需要讨论下，view和context之间耦合的方式。view产生的数据要交给BusinessObject进行处理，那么这二者之间必然要产生耦合。耦合的方式有很多种："}]},{type:a,value:c},{type:b,tag:r,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"只通过model进行耦合，二者只需要引用相同的model就可以进行交互，MVVM里view通过KVO的方式监听model变化就是这种耦合，这种耦合最弱，但调试会麻烦一些。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"通过model+protocol进行耦合。耦合的双方需要引用相同的model和protocol文件。这种方式属于面向接口编程的范畴，耦合也比较弱，但比上面的方式强。优点是调试方便，delegate的调试可以单步step into。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"通过model＋class进行耦合。这是我们最不愿意看到的耦合方式，类与类之间直接相互引用，任何一方变化都有可能引起潜在的bug。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"view与context之间耦合的方式采用的是第二种，方便调试且耦合清晰。view会引用business object和data handler实现的相关协议，进而调用。"}]},{type:a,value:c},{type:b,tag:u,props:{id:C},children:[{type:b,tag:f,props:{href:"#3cdd%E6%9E%B6%E6%9E%84demo%E5%AE%9E%E6%88%98",ariaHidden:m,tabIndex:n},children:[{type:b,tag:o,props:{className:[p,q]},children:[]}]},{type:b,tag:k,props:{},children:[{type:a,value:D}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"No Code，No BB。接下来我们用这套CDD的方案来实现一个类似微信的聊天界面。附上github DEMO地址，与朋友们一起学习研究。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"我们会通过demo实现这样一个Controller："}]},{type:a,value:c},{type:b,tag:l,props:{src:"http:\u002F\u002Fmrpeak.cn\u002Fimages\u002Fcdd_chat.jpg",width:I},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"这个demo主要实现两个功能来帮助大家了解CDD的workflow。一个是上面提到过的发送消息流程，二是点击头像之后可以进入用户详情的Controller，详情Controller里面可以改变用户的名字，改变之后聊天界面的MrPeak的名字也会以数据驱动的方式自动更新。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:k,props:{},children:[{type:a,value:"Demo实现细节："}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"CDD实现并不复杂，关键类如下："}]},{type:a,value:c},{type:b,tag:l,props:{src:"http:\u002F\u002Fmrpeak.cn\u002Fimages\u002Fcdd_structure.png",width:265},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"CDDContext就是之前提到的核心类context，还包含CDDDataHandler， CDDBusinessObject基类的定义。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"NSObject+CDD给每个NSObject对象添加一个CDDContext指针。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"UIView+CDD则通过swizzling的方式给每个UIView自动添加CDD。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"CDDMutableArray实现对Array的观察者模型。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"针对某个Controller实现规范如下："}]},{type:a,value:c},{type:b,tag:l,props:{src:"http:\u002F\u002Fmrpeak.cn\u002Fimages\u002Fcdd_demo.png",width:292},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"CDDContext，CDDDataHandler，CDDBusinessObject均在Controller当中生成。protocol定义接口部分的耦合。ViewModel是应用层当中的model，和View的展示通过KVO直接绑定。View部分则是我们拆分过后的子view。"}]},{type:a,value:c},{type:b,tag:u,props:{id:E},children:[{type:b,tag:f,props:{href:"#4cdd%E6%9E%B6%E6%9E%84%E5%90%8E%E7%BB%AD%E5%B7%A5%E4%BD%9C",ariaHidden:m,tabIndex:n},children:[{type:b,tag:o,props:{className:[p,q]},children:[]}]},{type:b,tag:k,props:{},children:[{type:a,value:F}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"CDD还处于初级阶段，是很久之前脑洞的产物，最近空一点才找机会把他变成代码。后面我会尝试在成熟的项目里去进一步完善并应证其合理性，也欢迎朋友们一起研究讨论。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"后期可能进行的工作有："}]},{type:a,value:c},{type:b,tag:r,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"完善对更多集合类的支持，比如Dictionary, Set等。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"BusinessObject在业务庞大的时候还是有可能膨胀，变得难以维护，可以尝试做进一步分解。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"现在Context的赋值是通过didAddSubview去hack实现的，应该还有更多的场景需要去完善。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"现在每个UIView包括系统（比如导航栏）控件都会去赋值Context，可能需要一种机制只对定制的UIView进行赋值。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"给Demo添加更多的功能场景。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"待补充。。。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fgithub.com\u002Fmusic4kid\u002FCDD",rel:[g,h,i],target:j},children:[{type:a,value:"github demo地址"}]}]}]},dir:"\u002Fwiki\u002FiOS",path:J,extension:".md",createdAt:K,updatedAt:K},prev:{slug:"openCV-EasyPR集成到iOS平台",title:"EasyPR集成到iOS平台",date:"2017-09-25T11:30:15.000Z"},next:{slug:L,title:M,date:s},scrollTop:N,sideCategory:[{folderName:"iOS",articles:[{slug:"iOS-Swift-ObjectMapper 指南",title:"Swift-ObjectMapper 指南",date:"2016-05-23 16:13",path:"\u002Fwiki\u002FiOS\u002FiOS-Swift-ObjectMapper 指南"},{slug:"iOS-URL Schemes && Universal Links 简单使用",title:"URL Schemes && Universal Links 简单使用",date:"2017-02-14T00:00:00.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-URL Schemes && Universal Links 简单使用"},{slug:"iOS-YYModel",title:"YYModel几种使用场景",date:O,path:"\u002Fwiki\u002FiOS\u002FiOS-YYModel"},{slug:"iOS-ios-useful-link",title:"'实用链接",date:"2017-07-14T16:58:04.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-ios-useful-link"},{slug:w,title:x,date:s,path:J},{slug:"iOS-检测离屏渲染与绘制高性能圆角",title:"(待)检测离屏渲染与绘制高性能圆角",date:"2017-08-17T10:03:56.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-检测离屏渲染与绘制高性能圆角"},{slug:"iOS-深度重构UIViewController",title:"(转)mrpeak杂货铺-深度重构UIViewController",date:"2017-11-19T21:33:42.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-深度重构UIViewController"},{slug:L,title:M,date:s,path:"\u002Fwiki\u002FiOS\u002FiOS-添加字体库"}],children:[{folderName:"3part",articles:[{slug:"3part-umeng-install",title:"快速集成友盟分享",date:"2018-03-01 16:11",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-umeng-install"},{slug:"3part-快速集成微信支付",title:"快速集成微信\u002F支付宝\u002F银联",date:"2017-11-17T16:19:25.000Z",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-快速集成微信支付"},{slug:"3part-快速集成百度地图",title:"集成百度地图、百度导航",date:"2017-08-11T11:24:43.000Z",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-快速集成百度地图"},{slug:"3part-阿里云视频点播集成",date:"2020-10-26T01:10:15.000Z",title:"阿里云视频点播VOD",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-阿里云视频点播集成"}],children:[]},{folderName:"Autolayout",articles:[{slug:"Autolayout-baseline",title:"label底部对齐、顶部对齐",date:P,path:"\u002Fwiki\u002FiOS\u002FAutolayout\u002FAutolayout-baseline"}],children:[]},{folderName:"Error",articles:[{slug:"Error-2017-07-31",title:"Undefined symbols for architecture ..",date:"2017-07-31T08:52:40.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-2017-07-31"},{slug:"Error-Shell-Script-Invocation-Error",title:"'Shell Script Invocation Error'",date:"2017-07-20T14:27:04.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-Shell-Script-Invocation-Error"},{slug:"Error-gesture",title:"tableViewCell的点击和tapGestureRecognizer冲突的处理",date:"2016-11-19T21:33:42.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-gesture"},{slug:"Error-崩溃分析",date:"2020-11-11T07:28:34.000Z",title:"崩溃分析(转载)",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-崩溃分析"},{slug:"Error-竖屏下视频全屏播放",title:"(转)竖屏下视频全屏播放",date:"2017-08-01T15:23:01.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-竖屏下视频全屏播放"},{slug:"Error-证书过期或者移除对app的影响",title:"证书过期或者移除对app的影响",date:"2018-01-11T13:49:33.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-证书过期或者移除对app的影响"}],children:[]},{folderName:"Objective-C",articles:[{slug:"Objective-C-KVO - Observe property of an object contained in a NSArray",title:"KVO - Observe property of an object contained in a NSArray",date:"2017-09-28 22:26",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-KVO - Observe property of an object contained in a NSArray"},{slug:"Objective-C-NSArrayFilter",title:"NSArray: filteredArrayUsingPredicate",date:"2017-09-14 16:24",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-NSArrayFilter"},{slug:"Objective-C-NSRecursiveLock",date:"2020-10-27T00:52:16.000Z",title:"NSRecursiveLock",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-NSRecursiveLock"},{slug:"Objective-C-NSStringCompareOptions",title:"NSStringCompareOptions",date:"2017-07-10T17:13:25.000Z",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-NSStringCompareOptions"},{slug:"Objective-C-containsObject-or-removeObject",title:"containsObject or removeObject",date:"2015年04月12日09:55:35",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-containsObject-or-removeObject"},{slug:"Objective-C-get-lunarholidays",title:"节气、节假日计算",date:"2017-07-13T09:30:26.000Z",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-get-lunarholidays"},{slug:"Objective-C-use-dispatch_queue_t-with-strong",title:"dispatch_queue_t 用strong来修饰",date:O,path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-use-dispatch_queue_t-with-strong"},{slug:"Objective-C-农历",title:"农历",date:"2017-07-11T13:12:46.000Z",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-农历"},{slug:"Objective-C-常用的宏",title:"常用的宏",date:"2015-03-04 11:11",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-常用的宏"}],children:[]},{folderName:"StatusBar",articles:[{slug:"StatusBar-how-to-detect-touches-in-status-bar",title:"获取StatusBar的点击事件",date:Q,path:"\u002Fwiki\u002FiOS\u002FStatusBar\u002FStatusBar-how-to-detect-touches-in-status-bar"},{slug:"StatusBar-ios-status-bar-style",title:"修改StatusBarStyle以及statusBar的背景颜色",date:Q,path:"\u002Fwiki\u002FiOS\u002FStatusBar\u002FStatusBar-ios-status-bar-style"}],children:[]},{folderName:"UIKit",articles:[{slug:"UIKit-UIAlertController修改文字对齐方式",date:"2020-10-23T08:07:07.000Z",title:"UIAlertController修改文字对齐方式",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-UIAlertController修改文字对齐方式"},{slug:"UIKit-UIDynamic Animator",title:"UIDynamic Animator",date:"2016-07-20T16:13:11.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-UIDynamic Animator"},{slug:"UIKit-UISplit​View​Controller 学习笔记",title:"UISplit​View​Controller 学习笔记",date:"2017-04-07T00:00:00.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-UISplit​View​Controller 学习笔记"},{slug:"UIKit-searchBar-style",title:"如何修改searchBar的样式",date:"2017-05-14T19:01:01.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-searchBar-style"},{slug:"UIKit-uioffset",title:"UIOffset",date:"2017-08-02T15:30:01.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-uioffset"},{slug:"UIKit-屏幕旋转.md",date:"2020-11-09T06:04:42.000Z",title:"屏幕旋转",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-屏幕旋转.md"},{slug:"UIKit-离屏渲染",title:"(转)关于iOS离屏渲染的深入研究",date:"2020-04-06T00:00:00.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-离屏渲染"},{slug:"UIKit-给WebView添加个粗糙的加载动画",title:"给UIWebView添加个粗糙的加载动画",date:"2017-02-10T00:00:00.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-给WebView添加个粗糙的加载动画"}],children:[]},{folderName:"UITextFeild",articles:[{slug:"UITextFeild-2018-01-16",title:"修改光标颜色和clear button的颜色",date:"2018-01-16T15:44:44.000Z",path:"\u002Fwiki\u002FiOS\u002FUITextFeild\u002FUITextFeild-2018-01-16"},{slug:"UITextFeild-uitextfeild-select-all",title:"默认选中文本",date:"2017-07-07 04:44",path:"\u002Fwiki\u002FiOS\u002FUITextFeild\u002FUITextFeild-uitextfeild-select-all"}],children:[]},{folderName:"keyboard",articles:[{slug:"keyboard-disable-3rd-keyboard",title:"禁用第三方键盘",date:P,path:"\u002Fwiki\u002FiOS\u002Fkeyboard\u002Fkeyboard-disable-3rd-keyboard"}],children:[]},{folderName:"loc",articles:[{slug:"loc-2018-01-22",title:"CLPlacemark中文",date:"2018-01-22T14:36:49.000Z",path:"\u002Fwiki\u002FiOS\u002Floc\u002Floc-2018-01-22"},{slug:"loc-sim-locaiton-ios",title:"真机或模拟器修改定位位置",date:"2017-08-11T10:29:01.000Z",path:"\u002Fwiki\u002FiOS\u002Floc\u002Floc-sim-locaiton-ios"}],children:[]},{folderName:"tableView",articles:[{slug:"tableView-cell-seprateLine",title:"cell分割线的颜色",date:"2017-08-08T15:26:14.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-cell-seprateLine"},{slug:"tableView-compare-NSIndexPath",title:"compare NSIndexPath",date:"2017-08-15T17:01:49.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-compare-NSIndexPath"},{slug:"tableView-tabeleView 获取某个cell的高度",title:"tabeleView 获取某个cell的高度",date:"2017-05-09T10:36:29.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-tabeleView 获取某个cell的高度"},{slug:"tableView-taleview-headerfooterView-xib",title:"xib UITableViewHeaderFooterView",date:"2017-08-18T09:47:36.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-taleview-headerfooterView-xib"},{slug:"tableView-结合layoutMargins做tableViewCell的适配",title:"结合layoutMargins做cell的适配",date:"2017-08-20T21:55:52.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-结合layoutMargins做tableViewCell的适配"}],children:[]},{folderName:"xib",articles:[{slug:"xib-如何替换已有的控件",title:"如何替换已有的控件",date:"2017-09-07T10:51:38.000Z",path:"\u002Fwiki\u002FiOS\u002Fxib\u002Fxib-如何替换已有的控件"}],children:[]},{folderName:"代码片段",articles:[{slug:"代码片段-分割小说章节",title:"分割小说章节",date:"2017-01-18T15:12:12.000Z",path:"\u002Fwiki\u002FiOS\u002F代码片段\u002F代码片段-分割小说章节"},{slug:"代码片段-截图 截长图 高清图",title:"截图 截长图 高清图",date:"2016-05-04 22:38",path:"\u002Fwiki\u002FiOS\u002F代码片段\u002F代码片段-截图 截长图 高清图"},{slug:"代码片段-读取未知类型的txt文件",title:"读取未知类型的txt文件 ",date:"2017-01-16 20:12",path:"\u002Fwiki\u002FiOS\u002F代码片段\u002F代码片段-读取未知类型的txt文件"}],children:[]},{folderName:"包管理工具",articles:[{slug:"包管理工具-spm-introduce",date:"2020-11-18T08:08:33.000Z",title:"Swift Package Manager介绍",path:"\u002Fwiki\u002FiOS\u002F包管理工具\u002F包管理工具-spm-introduce"},{slug:"包管理工具-spm-resource-handle",date:"2020-11-19T00:58:59.000Z",title:"SWift Package Manager资源文件管理",path:"\u002Fwiki\u002FiOS\u002F包管理工具\u002F包管理工具-spm-resource-handle"}],children:[]},{folderName:"日历",articles:[{slug:"日历-FSCalendar",title:"FSCalendar",date:"2017-07-11T08:48:12.000Z",path:"\u002Fwiki\u002FiOS\u002F日历\u002F日历-FSCalendar"}],children:[]},{folderName:"适配",articles:[{slug:"适配-NFC初试",title:"NFC初试",date:"2017-06-07 18:31",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-NFC初试"},{slug:"适配-iOS11 Xcode9新功能新特性",title:"iOS11 Xcode9新功能新特性",date:R,path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11 Xcode9新功能新特性"},{slug:"适配-iOS11 tableView适配不完全指南",title:"iOS11 tableView适配不完全指南",date:"2017-09-19 12:33",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11 tableView适配不完全指南"},{slug:"适配-iOS11刘海屏EdgeProtect相关",date:"2020-10-26T06:00:25.000Z",title:"iOS11刘海屏EdgeProtect相关",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11刘海屏EdgeProtect相关"},{slug:"适配-iOS11适配参考",title:"iOS11 适配参考",date:R,path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11适配参考"},{slug:"适配-iOS14hidesBottomBarWhenPushed兼容问题",date:"2020-10-23T08:53:49.000Z",title:"iOS14 hidesBottomBarWhenPushed兼容问题",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS14hidesBottomBarWhenPushed兼容问题"},{slug:"适配-touch-id",title:"touch Id",date:"2017-08-04T13:46:10.000Z",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-touch-id"}],children:[]},{folderName:"问与答",articles:[{slug:"问与答-为什么ui操作要在主线程",date:"2020-11-16T03:38:48.000Z",title:"为什么ui操作要在主线程",path:"\u002Fwiki\u002FiOS\u002F问与答\u002F问与答-为什么ui操作要在主线程"}],children:[]}]}]}],fetch:{},mutations:N}}("text","element","\n","p","li","a","nofollow","noopener","noreferrer","_blank","strong","img","true",-1,"span","icon","icon-link","ul","2017-10-27T18:01:13.000Z",2,"h2","，","iOS-mrpeak杂货铺-iOS应用层架构之CDD","(转)mrpeak杂货铺-iOS应用层架构之CDD","1应用层架构定义","1.应用层架构定义","2cdd架构详解","2.CDD架构详解","3cdd架构demo实战","3.CDD架构Demo实战","4cdd架构后续工作","4.CDD架构后续工作","http:\u002F\u002Fmrpeak.cn\u002Fblog\u002Fcdd\u002F","。",320,"\u002Fwiki\u002FiOS\u002FiOS-mrpeak杂货铺-iOS应用层架构之CDD","2022-01-20T03:55:04.535Z","iOS-添加字体库","使用第三方字体",void 0,"2017-08-31T09:32:08.000Z","2017-08-19T16:10:51.000Z","2016-07-01T14:19:23.000Z","2017-09-20T15:20:33.000Z")));
__NUXT_JSONP__("/wiki/content/iOS-%E6%B7%B1%E5%BA%A6%E9%87%8D%E6%9E%84UIViewController", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap){return {data:[{},{article:{slug:Q,title:R,layout:"page",date:S,toc:[{id:B,depth:q,text:B},{id:C,depth:q,text:C},{id:T,depth:q,text:U},{id:D,depth:q,text:D},{id:E,depth:q,text:E},{id:F,depth:q,text:F}],body:{type:"root",children:[{type:b,tag:f,props:{},children:[{type:a,value:"UIViewController是iOS应用的基础业务单位，每个iOS程序员都写过无数的Controller。今天和大家一起来深度解剖Controller，看看怎么来做一次深度的重构。"}]},{type:a,value:d},{type:b,tag:r,props:{id:B},children:[{type:b,tag:l,props:{href:"#%E9%87%8D%E6%9E%84%E7%9A%84%E5%89%8D%E6%8F%90",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:B}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"我们应该谨慎的去重构我们的代码。iOS系统提供的UIViewController一定程度上可以很好的应付简单的页面单位，对于复杂的页面，我们也可以采用市面上主流的MV(X)系列模式，比如MVP，MVVM等。但随着单个Controller内业务进一步增长，我们需要更细粒度的重构，或者说对MV(X)做进一步的定制。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"以下图映客App两个页面为例。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:"img",props:{alt:"2017111916058controller00.png",src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F2017111916058controller00.png"},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"左边页面元素少且静态，一个TableView基本上就能应付，右边的直播页面则元素多且动态，传统的MV(X)也会显得粒度太粗，这类复杂页面虽然不常遇到，但往往体现一个App的核心功能，合理的搭建或者重构这类Controller十分重要。"}]},{type:a,value:d},{type:b,tag:r,props:{id:C},children:[{type:b,tag:l,props:{href:"#%E9%87%8D%E6%9E%84%E7%9A%84%E6%9C%AC%E8%B4%A8",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:C}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"如何去定义重构，以我的理解可以归纳为两个关键词：分解，连接。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"重构的前提是复杂，臃肿，不直观，重构的手段是分解之后再连接。以映客的直播界面为例，UI元素，用户事件，服务器交互等基础元素都非常之多，以一个简单的MVP去归类代码犹嫌不足，我们还需要进一步的分解成view1,view2…viewN,presenter1,presenter2…presenterN,model1,model2…modelN，第二个问题是如何把这一个个的类文件或者说功能单位合理组织连接起来。完成上述两步我们就完成了一次重构，每一次将代码打散再串联就是一次重构。"}]},{type:a,value:d},{type:b,tag:r,props:{id:T},children:[{type:b,tag:l,props:{href:"#%E5%88%86%E8%A7%A3uiviewcontroller",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:U}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"写了那么多Controller，让你来说下一个Controller都细分为哪些更小的功能单位，你能随口说出来么？只有做过足够多的业务，才能慢慢对Controller的构成有自己的理解。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"当然可以回答说MVC或者MVP，但这个答案粒度太粗，一个Controller内部会发生哪些事可以说的更细，我们看下VIPER的答案："}]},{type:a,value:d},{type:b,tag:V,props:{},children:[{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:"View"}]},{type:a,value:": displays what it is told to by the Presenter and relays user input back to the Presenter."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:"Interactor"}]},{type:a,value:": contains the business logic as specified by a use case.\n"},{type:b,tag:n,props:{},children:[{type:a,value:"Presenter"}]},{type:a,value:": contains view logic for preparing content for display (as received from the Interactor) and for reacting to user inputs (by requesting new data from the Interactor).\n"},{type:b,tag:n,props:{},children:[{type:a,value:"Entity"}]},{type:a,value:": contains basic model objects used by the Interactor.\n"},{type:b,tag:n,props:{},children:[{type:a,value:"Routing"}]},{type:a,value:": contains navigation logic for describing which screens are shown in which order"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"View不用多说，可以分解成更多的子View，最后合成一个树形结构。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Entity自然是代表Model。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"MVC当中的C，MVP当中的P，被细分成了Interactor，Presenter，和Routing。这三个角色各自负责什么职责呢？"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Routing比较清楚，处理页面之间的跳转。我见过的项目代码里，很少有把这一部分单独拎出来的，但其实很有意义，这部分代表的是不同Controller之间耦合依赖的方式，无论是从类关系描述的角度还是Debug的角度，都能帮助我们快速定位代码。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Interactor和Presenter初看起来很类似，似乎都是在处理业务逻辑。但业务逻辑其实是个大的归类，可以描述任何一种业务场景和行为。Interactor当中有个很重要的术语：use case，这个术语很多技术文章中都会遇见，它代表的是一个完整的，独立的，细分过后的业务流程，比如我们App当中的登录模块，它是一个业务单位，但它其实可以进一步的细分为很多的use case："}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"use case 1: 验证邮箱长度"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"use case 2: 密码强度检验"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"use case 3: 从Server查询user name是否可用"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"…"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"user case N"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"定义use case有什么好处呢？"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"好处当然是分门别类，结构清晰。你把100本书堆一堆，或者放书架上按类别摆放，下次找书的时候那种方式你更舒服？独立出一个个的use case还有一个好处是方便unit test，如果项目对每一个use case都有写对应的unit test，每次遇到“前一发动全身“的业务更改，可以边杯茶边写代码。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"我见过不少代码都体现不出use case的分类，可以回头看下自己当前项目的登录模块，上面我提到的这些case有没有在类文件当中合理摆放，还是都搅在一起？"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"所以VIPER当中interactor的说法是强化大家写单独的use case的意识，打开interactor.m，看到一个函数代表一个use case，同一类的use case再用#pragma mark 归在一块，别人看你代码时能不赏心悦目吗？"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"再说到Presenter，Presenter可以看做是上面一个个use case的使用者和响应者。使用者将各个use case串联起来描述一个完整详细的业务流程，比如我们的登录模块，每次用户点击按钮注册的时候，会触发一系列的use case，从检验用户输入合法性，设备网络状态，服务器资源是否可用，到最后处理结果并展示，这就是一个完整的业务流程，这个流程由Presenter来描述。响应者表示Presenter在接收到服务器反馈之后进一步改变本地的状态，比如view的展示，新的数据修改等，甚至会调用Routing发生页面跳转。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"说到这里就比较明了了，interactor和routing都是服务的提供方，presenter是服务的使用和集成方。VIPER说白了不过是对传统的MVC当中的C做了进一步细分。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:"能不能分的更细呢？"}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"当然可以，VIPER的分法是一种通用的做法，我们还可以从业务的角度去做细分。拿映客的直播界面做例子，比如Presenter当中包含了很多完整的业务流程："}]},{type:a,value:d},{type:b,tag:"ul",props:{},children:[{type:a,value:d},{type:b,tag:y,props:{},children:[{type:a,value:"收到用户消息并展示"}]},{type:a,value:d},{type:b,tag:y,props:{},children:[{type:a,value:"收到礼品消息并展示"}]},{type:a,value:d},{type:b,tag:y,props:{},children:[{type:a,value:"收到弹幕消息并展示"}]},{type:a,value:d},{type:b,tag:y,props:{},children:[{type:a,value:"收到用户进出房间的事件，处理并展示"}]},{type:a,value:d},{type:b,tag:y,props:{},children:[{type:a,value:"收到XXX，处理并展示"}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"以Objective C语言的特性，我们可以生成更多的Presenter Category来安置这些流程，比如LivePresenter+Message, LivePresenter+Gift, LivePresenter+Danmu, LivePresenter+Room, LivePresenter+XXX。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"不要觉得上面几个业务流程很简单，一个presenter处理绰绰有余，我前段时间刚好做过一个直播项目，Presenter类超过1000行代码很轻松。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"还可以进一步细分，一个功能复杂繁多的页面基本上离不开UITableView，而tableview的代码量主要在于delegate和datasource。这两个职责当然可以放在presenter当中，或者我们向Android学习，把它们也独立出来放到单独的类文件中去处理，比如叫做Adapter，用代码来说就是："}]},{type:a,value:d},{type:b,tag:W,props:{className:[X]},children:[{type:b,tag:Y,props:{className:[Z,_]},children:[{type:b,tag:$,props:{},children:[{type:a,value:"_tableView"},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:G}]},{type:a,value:"delegate "},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:aa}]},{type:a,value:o},{type:b,tag:c,props:{className:[e,w]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:G}]},{type:a,value:ac},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:"\n_tableView"},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:G}]},{type:a,value:"dataSource "},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:aa}]},{type:a,value:o},{type:b,tag:c,props:{className:[e,w]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:G}]},{type:a,value:ac},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"和tableView相关的这些代码都搬到了adapter当中："}]},{type:a,value:d},{type:b,tag:W,props:{className:[X]},children:[{type:b,tag:Y,props:{className:[Z,_]},children:[{type:b,tag:$,props:{},children:[{type:b,tag:c,props:{className:[e,w]},children:[{type:a,value:ad}]},{type:a,value:" UITableViewDelegate\n\n"},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:z}]},{type:a,value:o},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:I},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:x},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:A},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:"tableView heightForRowAtIndexPath"},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:ae},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:af},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:z}]},{type:a,value:o},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:I},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:x},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:A},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:"tableView heightForHeaderInSection"},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:H},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:J},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:z}]},{type:a,value:o},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:I},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:x},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:A},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:"tableView heightForFooterInSection"},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:H},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:J},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:K},{type:b,tag:c,props:{className:[e,w]},children:[{type:a,value:ag}]},{type:a,value:K},{type:b,tag:c,props:{className:[e,w]},children:[{type:a,value:ad}]},{type:a,value:" UITableViewDataSource"},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:"\u003C"}]},{type:a,value:"NSObject"},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:"\u003E"}]},{type:a,value:K},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:"@"}]},{type:a,value:"required\n"},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:z}]},{type:a,value:o},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:H},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:x},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:A},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:"tableView numberOfRowsInSection"},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:H},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:J},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:z}]},{type:a,value:o},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:"UITableViewCell "},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:x},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:A},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:"tableView cellForRowAtIndexPath"},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:i}]},{type:a,value:ae},{type:b,tag:c,props:{className:[e,h]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:j}]},{type:a,value:af},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,w]},children:[{type:a,value:ag}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"我们的Presenter就变得更加干净了，看起来和刚大扫除过的房间一样令人愉悦。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"好了，到这里我们盘子里的牛排已经被切成很多小块了，可以开始享用这些美味的代码了，继续我们的第二步工作：连接。"}]},{type:a,value:d},{type:b,tag:r,props:{id:D},children:[{type:b,tag:l,props:{href:"#%E8%BF%9E%E6%8E%A5",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:D}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"先看下我们分解之后有哪些元素："}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"view(1…N), model(1…N), interactor, presenter(1…N), routing, adapter。看着应该粒度够细了，对于复杂的Controller，我个人习惯的做法和VIPER相近，但略有不同，Interactor当中的use case通过分层的架构被我放到server layer，分层的架构是另一个话题，这里不做细述。其他元素基本一致。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"至于怎么连接，手段无非就是OC的几种类交互机制："}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:"Delegate, Target-Action, Block, Notification, KVO。"}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"这几者之间的差异可以参考"},{type:b,tag:l,props:{href:"https:\u002F\u002Fwww.objc.io\u002Fissues\u002F7-foundation\u002Fcommunication-patterns\u002F",rel:[L,M,N],target:O},children:[{type:a,value:"objc.io的一篇经典文章"}]},{type:a,value:"。选择不同对耦合度，开发便捷性，调试是否方便等都会产生影响，如何应用不同的机制将各个单位串联起来就看架构师自己的积累和理解了，任何一个选择都有其优势和局限性。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"如果拿捏不准选哪个好的时候，我个人建议就使用delegate，朴素可靠且直观。delegate需要在不同的元素之间传递，代码量会偏多一些，但优点在protocol定义清晰，耦合在哪里一目了然，记得要注意循环引用的问题。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"我早些时候其他几种机制都在实际项目中做过尝试，最后综合比较还是倾向于选择delegate，再后来经过一番脑洞（主要是为了解决传递delegate所带来的额外代码量），利用runtime特性，做了一个CDD机制来自动串联各个功能单位。"},{type:b,tag:l,props:{href:"http:\u002F\u002Fwww.mrpeak.cn\u002Fblog\u002Fcdd\u002F",rel:[L,M,N],target:O},children:[{type:a,value:"CDD的详细介绍"}]},{type:a,value:"在之前的博客中有，这里也不细述了，其本质或者说最终目的还是在于连接。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"说完了分解和连接，Controller的重构完成了大半，还剩下一个至关重要的概念：状态分享。"}]},{type:a,value:d},{type:b,tag:r,props:{id:E},children:[{type:b,tag:l,props:{href:"#%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E8%B7%A8%E7%B1%BB%EF%BC%8C%E8%B7%A8%E6%A8%A1%E5%9D%97%E6%88%96%E8%B7%A8%E5%B1%82%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:E}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"我之前在一篇博客中谈到过对于"},{type:b,tag:l,props:{href:"http:\u002F\u002Fwww.mrpeak.cn\u002Fblog\u002Fstate\u002F",rel:[L,M,N],target:O},children:[{type:a,value:"程序状态的维护"}]},{type:a,value:"。状态是否维护得好对于程序的整体稳定性很有影响，对于Controller当中的状态维护我有一个简单的建议："}]},{type:a,value:d},{type:b,tag:V,props:{},children:[{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"传递状态的时候尽可能Copy"}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"之前流行的函数式编程其实就很强调无状态性，无状态不是让大家不定义状态变量，而是避免函数之间的状态共享，具体到OC当中，就是不要在不同的功能单位里使用指向同一块内存拷贝的地址，为什么共享状态是一件危险的事，我在之前的文章中也介绍过。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"一般来说，我们从Model Layer或者说数据层拿到的model实例，扔给Controller使用的时候应该是一份新的拷贝，在不同的类单位里共享NSMutableString或者NSMutableArray，NSMutableDictionary很容易让你的代码变得不稳定，而且这类不稳定性一般很难调试，debug填坑的时候经常按下葫芦浮起瓢。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"在controller内部传递model或者state的时候，我们应该也尽量使用copy行为，任何state你一旦暴露出去就不再安全，自己创建，自己修改，自己销毁才是正途。说到"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"我之前介绍Facebook架构的时候就提到过，Facebook当中的model layer是由一个单独开发团队维护的，应用层开发人员（Controller开发人员）获取到的都是新的拷贝，要修改某个属性不一定有接口，甚至要向model的维护团队提交增加接口的申请，对于state维护的谨慎度可见一斑。"}]},{type:a,value:d},{type:b,tag:r,props:{id:F},children:[{type:b,tag:l,props:{href:"#%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90%E5%8E%9F%E5%9E%8B%E4%BB%A3%E7%A0%81",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:F}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"说了这么多，Controller重构的关键点都说完了。最后再提个小Tip，一旦Controller做深度细分之后，团队成员需要对Controller的分法和构成有一致的认识，写出来的代码应该保持一致，我的做法是通过脚本的方式生成Controller各个相关的类文件."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"通过脚本将文件名和文件内容当中的Template全部替换成目标Controller的名字，就省去了很多重复代码的体力劳动，也达到了代码风格一致的目的。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"在公众号回复：Template ，可以下载脚本和UIViewController模板文件。"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"欢迎关注公众号：MrPeakTech"}]}]},dir:"\u002Fwiki\u002FiOS",path:ah,extension:".md",createdAt:ai,updatedAt:ai},prev:{slug:aj,title:ak,date:P},next:{slug:"ionic-handell-tag-a",title:"遍历\u003Ca\u003E标签,处理跳转操作",date:"2018-09-05 16:47"},scrollTop:al,sideCategory:[{folderName:"iOS",articles:[{slug:"iOS-Swift-ObjectMapper 指南",title:"Swift-ObjectMapper 指南",date:"2016-05-23 16:13",path:"\u002Fwiki\u002FiOS\u002FiOS-Swift-ObjectMapper 指南"},{slug:"iOS-URL Schemes && Universal Links 简单使用",title:"URL Schemes && Universal Links 简单使用",date:"2017-02-14T00:00:00.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-URL Schemes && Universal Links 简单使用"},{slug:"iOS-YYModel",title:"YYModel几种使用场景",date:am,path:"\u002Fwiki\u002FiOS\u002FiOS-YYModel"},{slug:"iOS-ios-useful-link",title:"'实用链接",date:"2017-07-14T16:58:04.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-ios-useful-link"},{slug:"iOS-mrpeak杂货铺-iOS应用层架构之CDD",title:"(转)mrpeak杂货铺-iOS应用层架构之CDD",date:P,path:"\u002Fwiki\u002FiOS\u002FiOS-mrpeak杂货铺-iOS应用层架构之CDD"},{slug:"iOS-检测离屏渲染与绘制高性能圆角",title:"(待)检测离屏渲染与绘制高性能圆角",date:"2017-08-17T10:03:56.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-检测离屏渲染与绘制高性能圆角"},{slug:Q,title:R,date:S,path:ah},{slug:aj,title:ak,date:P,path:"\u002Fwiki\u002FiOS\u002FiOS-添加字体库"}],children:[{folderName:"3part",articles:[{slug:"3part-umeng-install",title:"快速集成友盟分享",date:"2018-03-01 16:11",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-umeng-install"},{slug:"3part-快速集成微信支付",title:"快速集成微信\u002F支付宝\u002F银联",date:"2017-11-17T16:19:25.000Z",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-快速集成微信支付"},{slug:"3part-快速集成百度地图",title:"集成百度地图、百度导航",date:"2017-08-11T11:24:43.000Z",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-快速集成百度地图"},{slug:"3part-阿里云视频点播集成",date:"2020-10-26T01:10:15.000Z",title:"阿里云视频点播VOD",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-阿里云视频点播集成"}],children:[]},{folderName:"Autolayout",articles:[{slug:"Autolayout-baseline",title:"label底部对齐、顶部对齐",date:an,path:"\u002Fwiki\u002FiOS\u002FAutolayout\u002FAutolayout-baseline"}],children:[]},{folderName:"Error",articles:[{slug:"Error-2017-07-31",title:"Undefined symbols for architecture ..",date:"2017-07-31T08:52:40.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-2017-07-31"},{slug:"Error-Shell-Script-Invocation-Error",title:"'Shell Script Invocation Error'",date:"2017-07-20T14:27:04.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-Shell-Script-Invocation-Error"},{slug:"Error-gesture",title:"tableViewCell的点击和tapGestureRecognizer冲突的处理",date:"2016-11-19T21:33:42.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-gesture"},{slug:"Error-崩溃分析",date:"2020-11-11T07:28:34.000Z",title:"崩溃分析(转载)",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-崩溃分析"},{slug:"Error-竖屏下视频全屏播放",title:"(转)竖屏下视频全屏播放",date:"2017-08-01T15:23:01.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-竖屏下视频全屏播放"},{slug:"Error-证书过期或者移除对app的影响",title:"证书过期或者移除对app的影响",date:"2018-01-11T13:49:33.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-证书过期或者移除对app的影响"}],children:[]},{folderName:"Objective-C",articles:[{slug:"Objective-C-KVO - Observe property of an object contained in a NSArray",title:"KVO - Observe property of an object contained in a NSArray",date:"2017-09-28 22:26",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-KVO - Observe property of an object contained in a NSArray"},{slug:"Objective-C-NSArrayFilter",title:"NSArray: filteredArrayUsingPredicate",date:"2017-09-14 16:24",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-NSArrayFilter"},{slug:"Objective-C-NSRecursiveLock",date:"2020-10-27T00:52:16.000Z",title:"NSRecursiveLock",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-NSRecursiveLock"},{slug:"Objective-C-NSStringCompareOptions",title:"NSStringCompareOptions",date:"2017-07-10T17:13:25.000Z",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-NSStringCompareOptions"},{slug:"Objective-C-containsObject-or-removeObject",title:"containsObject or removeObject",date:"2015年04月12日09:55:35",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-containsObject-or-removeObject"},{slug:"Objective-C-get-lunarholidays",title:"节气、节假日计算",date:"2017-07-13T09:30:26.000Z",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-get-lunarholidays"},{slug:"Objective-C-use-dispatch_queue_t-with-strong",title:"dispatch_queue_t 用strong来修饰",date:am,path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-use-dispatch_queue_t-with-strong"},{slug:"Objective-C-农历",title:"农历",date:"2017-07-11T13:12:46.000Z",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-农历"},{slug:"Objective-C-常用的宏",title:"常用的宏",date:"2015-03-04 11:11",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-常用的宏"}],children:[]},{folderName:"StatusBar",articles:[{slug:"StatusBar-how-to-detect-touches-in-status-bar",title:"获取StatusBar的点击事件",date:ao,path:"\u002Fwiki\u002FiOS\u002FStatusBar\u002FStatusBar-how-to-detect-touches-in-status-bar"},{slug:"StatusBar-ios-status-bar-style",title:"修改StatusBarStyle以及statusBar的背景颜色",date:ao,path:"\u002Fwiki\u002FiOS\u002FStatusBar\u002FStatusBar-ios-status-bar-style"}],children:[]},{folderName:"UIKit",articles:[{slug:"UIKit-UIAlertController修改文字对齐方式",date:"2020-10-23T08:07:07.000Z",title:"UIAlertController修改文字对齐方式",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-UIAlertController修改文字对齐方式"},{slug:"UIKit-UIDynamic Animator",title:"UIDynamic Animator",date:"2016-07-20T16:13:11.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-UIDynamic Animator"},{slug:"UIKit-UISplit​View​Controller 学习笔记",title:"UISplit​View​Controller 学习笔记",date:"2017-04-07T00:00:00.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-UISplit​View​Controller 学习笔记"},{slug:"UIKit-searchBar-style",title:"如何修改searchBar的样式",date:"2017-05-14T19:01:01.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-searchBar-style"},{slug:"UIKit-uioffset",title:"UIOffset",date:"2017-08-02T15:30:01.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-uioffset"},{slug:"UIKit-屏幕旋转.md",date:"2020-11-09T06:04:42.000Z",title:"屏幕旋转",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-屏幕旋转.md"},{slug:"UIKit-离屏渲染",title:"(转)关于iOS离屏渲染的深入研究",date:"2020-04-06T00:00:00.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-离屏渲染"},{slug:"UIKit-给WebView添加个粗糙的加载动画",title:"给UIWebView添加个粗糙的加载动画",date:"2017-02-10T00:00:00.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-给WebView添加个粗糙的加载动画"}],children:[]},{folderName:"UITextFeild",articles:[{slug:"UITextFeild-2018-01-16",title:"修改光标颜色和clear button的颜色",date:"2018-01-16T15:44:44.000Z",path:"\u002Fwiki\u002FiOS\u002FUITextFeild\u002FUITextFeild-2018-01-16"},{slug:"UITextFeild-uitextfeild-select-all",title:"默认选中文本",date:"2017-07-07 04:44",path:"\u002Fwiki\u002FiOS\u002FUITextFeild\u002FUITextFeild-uitextfeild-select-all"}],children:[]},{folderName:"keyboard",articles:[{slug:"keyboard-disable-3rd-keyboard",title:"禁用第三方键盘",date:an,path:"\u002Fwiki\u002FiOS\u002Fkeyboard\u002Fkeyboard-disable-3rd-keyboard"}],children:[]},{folderName:"loc",articles:[{slug:"loc-2018-01-22",title:"CLPlacemark中文",date:"2018-01-22T14:36:49.000Z",path:"\u002Fwiki\u002FiOS\u002Floc\u002Floc-2018-01-22"},{slug:"loc-sim-locaiton-ios",title:"真机或模拟器修改定位位置",date:"2017-08-11T10:29:01.000Z",path:"\u002Fwiki\u002FiOS\u002Floc\u002Floc-sim-locaiton-ios"}],children:[]},{folderName:x,articles:[{slug:"tableView-cell-seprateLine",title:"cell分割线的颜色",date:"2017-08-08T15:26:14.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-cell-seprateLine"},{slug:"tableView-compare-NSIndexPath",title:"compare NSIndexPath",date:"2017-08-15T17:01:49.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-compare-NSIndexPath"},{slug:"tableView-tabeleView 获取某个cell的高度",title:"tabeleView 获取某个cell的高度",date:"2017-05-09T10:36:29.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-tabeleView 获取某个cell的高度"},{slug:"tableView-taleview-headerfooterView-xib",title:"xib UITableViewHeaderFooterView",date:"2017-08-18T09:47:36.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-taleview-headerfooterView-xib"},{slug:"tableView-结合layoutMargins做tableViewCell的适配",title:"结合layoutMargins做cell的适配",date:"2017-08-20T21:55:52.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-结合layoutMargins做tableViewCell的适配"}],children:[]},{folderName:"xib",articles:[{slug:"xib-如何替换已有的控件",title:"如何替换已有的控件",date:"2017-09-07T10:51:38.000Z",path:"\u002Fwiki\u002FiOS\u002Fxib\u002Fxib-如何替换已有的控件"}],children:[]},{folderName:"代码片段",articles:[{slug:"代码片段-分割小说章节",title:"分割小说章节",date:"2017-01-18T15:12:12.000Z",path:"\u002Fwiki\u002FiOS\u002F代码片段\u002F代码片段-分割小说章节"},{slug:"代码片段-截图 截长图 高清图",title:"截图 截长图 高清图",date:"2016-05-04 22:38",path:"\u002Fwiki\u002FiOS\u002F代码片段\u002F代码片段-截图 截长图 高清图"},{slug:"代码片段-读取未知类型的txt文件",title:"读取未知类型的txt文件 ",date:"2017-01-16 20:12",path:"\u002Fwiki\u002FiOS\u002F代码片段\u002F代码片段-读取未知类型的txt文件"}],children:[]},{folderName:"包管理工具",articles:[{slug:"包管理工具-spm-introduce",date:"2020-11-18T08:08:33.000Z",title:"Swift Package Manager介绍",path:"\u002Fwiki\u002FiOS\u002F包管理工具\u002F包管理工具-spm-introduce"},{slug:"包管理工具-spm-resource-handle",date:"2020-11-19T00:58:59.000Z",title:"SWift Package Manager资源文件管理",path:"\u002Fwiki\u002FiOS\u002F包管理工具\u002F包管理工具-spm-resource-handle"}],children:[]},{folderName:"日历",articles:[{slug:"日历-FSCalendar",title:"FSCalendar",date:"2017-07-11T08:48:12.000Z",path:"\u002Fwiki\u002FiOS\u002F日历\u002F日历-FSCalendar"}],children:[]},{folderName:"适配",articles:[{slug:"适配-NFC初试",title:"NFC初试",date:"2017-06-07 18:31",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-NFC初试"},{slug:"适配-iOS11 Xcode9新功能新特性",title:"iOS11 Xcode9新功能新特性",date:ap,path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11 Xcode9新功能新特性"},{slug:"适配-iOS11 tableView适配不完全指南",title:"iOS11 tableView适配不完全指南",date:"2017-09-19 12:33",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11 tableView适配不完全指南"},{slug:"适配-iOS11刘海屏EdgeProtect相关",date:"2020-10-26T06:00:25.000Z",title:"iOS11刘海屏EdgeProtect相关",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11刘海屏EdgeProtect相关"},{slug:"适配-iOS11适配参考",title:"iOS11 适配参考",date:ap,path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11适配参考"},{slug:"适配-iOS14hidesBottomBarWhenPushed兼容问题",date:"2020-10-23T08:53:49.000Z",title:"iOS14 hidesBottomBarWhenPushed兼容问题",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS14hidesBottomBarWhenPushed兼容问题"},{slug:"适配-touch-id",title:"touch Id",date:"2017-08-04T13:46:10.000Z",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-touch-id"}],children:[]},{folderName:"问与答",articles:[{slug:"问与答-为什么ui操作要在主线程",date:"2020-11-16T03:38:48.000Z",title:"为什么ui操作要在主线程",path:"\u002Fwiki\u002FiOS\u002F问与答\u002F问与答-为什么ui操作要在主线程"}],children:[]}]}]}],fetch:{},mutations:al}}("text","element","span","\n","token","p","punctuation","operator","(",")",":","a","*","strong"," ",";",2,"h2","true",-1,"icon","icon-link","keyword","tableView","li","-","UITableView ","重构的前提","重构的本质","连接","尽量避免跨类，跨模块或跨层共享状态","使用脚本生成原型代码",".","NSInteger","CGFloat","section","\n\n","nofollow","noopener","noreferrer","_blank","2017-10-27T18:01:13.000Z","iOS-深度重构UIViewController","(转)mrpeak杂货铺-深度重构UIViewController","2017-11-19T21:33:42.000Z","分解uiviewcontroller","分解UIViewController","blockquote","div","nuxt-content-highlight","pre","language-objc","line-numbers","code","=","self","adapter","@protocol","NSIndexPath ","indexPath","@end","\u002Fwiki\u002FiOS\u002FiOS-深度重构UIViewController","2021-10-15T10:03:44.816Z","iOS-添加字体库","使用第三方字体",void 0,"2017-08-31T09:32:08.000Z","2017-08-19T16:10:51.000Z","2016-07-01T14:19:23.000Z","2017-09-20T15:20:33.000Z")));
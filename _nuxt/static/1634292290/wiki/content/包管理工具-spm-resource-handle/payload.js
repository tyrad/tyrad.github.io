__NUXT_JSONP__("/wiki/content/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-spm-resource-handle", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj){return {data:[{},{article:{slug:L,draft:false,date:M,title:N,toc:[{id:r,depth:j,text:r},{id:s,depth:j,text:s},{id:t,depth:j,text:t},{id:u,depth:j,text:u},{id:v,depth:j,text:v},{id:w,depth:j,text:w},{id:x,depth:j,text:x}],body:{type:"root",children:[{type:b,tag:O,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"原文地址 "},{type:b,tag:g,props:{href:"https:\u002F\u002Fjuejin.im\u002Fpost\u002F6854573220784242702",rel:[y,z,A],target:B},children:[{type:a,value:"juejin.im"}]}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"从更新到现在，SwiftPM 令人诟病的一个问题就是无法在包里添加资源文件。这对于已经习惯于使用 CocoaPods 的开发者造成了很大的麻烦，当然目前 SwiftPM 差于 Cocoapods 不止这一点。SwiftPM 也意识到了这一点，从去年就可以看到 github 的 SwiftPM 对应仓库的有 "},{type:b,tag:d,props:{},children:[{type:a,value:C}]},{type:a,value:" 等 API 相关提交。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"此次的 SwiftPM 更新中除了上面说的可以添加资源文件，还添加了本地化等功能。下面介绍下 WWDC-2020 上该 Session 的内容。"}]},{type:a,value:c},{type:b,tag:k,props:{id:r},children:[{type:b,tag:g,props:{href:"#%E9%85%8D%E7%BD%AE%E8%A6%81%E6%B1%82",ariaHidden:l,tabIndex:m},children:[{type:b,tag:n,props:{className:[o,p]},children:[]}]},{type:a,value:r}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"SwiftPM 的资源文件管理功能在 swift-tool-version 5.3，即 Swift 5.3，对应 Xcode 12。所以 "},{type:b,tag:d,props:{},children:[{type:a,value:q}]},{type:a,value:" 配置中需要声明 swift 5.3 以上 (这行并不是注释，而是文件解析中必须的配置)："}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:h,props:{alt:i,src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F173902399ac5ded7.webp"},children:[]}]},{type:a,value:c},{type:b,tag:k,props:{id:s},children:[{type:b,tag:g,props:{href:"#%E6%B7%BB%E5%8A%A0%E5%92%8C%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6",ariaHidden:l,tabIndex:m},children:[{type:b,tag:n,props:{className:[o,p]},children:[]}]},{type:a,value:s}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"对于一些使用目的明确的文件类型，比如下面图中的这些。开发者不需要在 "},{type:b,tag:d,props:{},children:[{type:a,value:q}]},{type:a,value:" 文件中配置任何东西，因为 Xcode 知道这些类型的文件是代表什么，比如 "},{type:b,tag:d,props:{},children:[{type:a,value:P}]},{type:a,value:" 文件代表图片、颜色资源， "},{type:b,tag:d,props:{},children:[{type:a,value:Q}]},{type:a,value:" 代表用户界面文件等"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:h,props:{alt:i,src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F1739022bc9bf195d.webp"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"而对于一些使用目的不太明确的文件类型（如下图中的一些文件类型），则需要在 "},{type:b,tag:d,props:{},children:[{type:a,value:q}]},{type:a,value:" 文件中配置。例如纯文本文件，这种文件中的数据可能是需要在运行时被加载而计算或者展示，也可能只是一个开发者文档。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:h,props:{alt:i,src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F173902416d4a08dd.webp"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"对于上面这种意义不明的文件，就需要在 "},{type:b,tag:d,props:{},children:[{type:a,value:q}]},{type:a,value:" 清单中根据规则配置，下面以这个 GameLogin 作为例子："}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:h,props:{alt:i,src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F17390245c75fe8bc.webp"},children:[]}]},{type:a,value:c},{type:b,tag:D,props:{},children:[{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"对于 "},{type:b,tag:d,props:{},children:[{type:a,value:"Media.xcasset"}]},{type:a,value:R},{type:b,tag:d,props:{},children:[{type:a,value:"main.storyboard"}]},{type:a,value:" 文件，Xcode 能明确知道它代表什么，所以不需要在这个配置文件中标记"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:d,props:{},children:[{type:a,value:"internal Note.txt"}]},{type:a,value:" 文件和 "},{type:b,tag:d,props:{},children:[{type:a,value:"Artwork Creation"}]},{type:a,value:" 文件夹是模块内部文件，所以写在 "},{type:b,tag:d,props:{},children:[{type:a,value:"target"}]},{type:a,value:" 的 "},{type:b,tag:d,props:{},children:[{type:a,value:"exclude"}]},{type:a,value:" 属性中，这样 Xcode 就不会把它编译到包里"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"其他不能自动识别的类型并且需要被加载到 package 里的文件则配置在 "},{type:b,tag:d,props:{},children:[{type:a,value:C}]},{type:a,value:S}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"上面就是配置资源文件的一些规则，其中我们可以看到对于 "},{type:b,tag:d,props:{},children:[{type:a,value:C}]},{type:a,value:" 属性，有两个静态方法： "},{type:b,tag:d,props:{},children:[{type:a,value:T}]},{type:a,value:R},{type:b,tag:d,props:{},children:[{type:a,value:U}]},{type:a,value:" 。根据 session 中的介绍， "},{type:b,tag:d,props:{},children:[{type:a,value:T}]},{type:a,value:" 是推荐的方式，它所配置的文件会根据具体使用的平台和内置规则进行适当的优化。比如在运行时将 "},{type:b,tag:d,props:{},children:[{type:a,value:"storyboard"}]},{type:a,value:E},{type:b,tag:d,props:{},children:[{type:a,value:"asset catalog"}]},{type:a,value:" 转换成适当的形式，也包括压缩图片等。如果文件类型无法识别，或者不能根据平台做任何优化，就只会被简单的拷贝，也就是 "},{type:b,tag:d,props:{},children:[{type:a,value:U}]},{type:a,value:" 。"}]},{type:a,value:c},{type:b,tag:k,props:{id:t},children:[{type:b,tag:g,props:{href:"#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B",ariaHidden:l,tabIndex:m},children:[{type:b,tag:n,props:{className:[o,p]},children:[]}]},{type:a,value:t}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"当一个 App 使用 package 时，这个 package 包括源文件和资源文件。在编译时首先会将 Package 中每个 target 的源文件编译成 module 链接到 App 中，然后这些 target 中的资源文件则会被加工成 bundle 放到这些 module 中。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:h,props:{alt:i,src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F1739024d9ad1d379.webp"},children:[]}]},{type:a,value:c},{type:b,tag:O,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"在 Apple 平台中，App 和 App extension 都是 bundle 集合，这些 package 的 bundle 就是 App 的一部分，所以不需要做其他处理，就能在运行时获取这些 bundle。 当被编译到一个 unbundle 产物时，比如脚本工具，则需要在脚本启动的同时加载资源 bundle(这一步的具体步骤还不太理解)"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:k,props:{id:u},children:[{type:b,tag:g,props:{href:"#%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6",ariaHidden:l,tabIndex:m},children:[{type:b,tag:n,props:{className:[o,p]},children:[]}]},{type:a,value:u}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"在编译有资源文件的 Package 中，会自动创建并添加到 module 中一个文件： "},{type:b,tag:d,props:{},children:[{type:a,value:"resource_bundle_accessor.swift"}]},{type:a,value:" ，里面的内容大概等价于下面这样："}]},{type:a,value:c},{type:b,tag:F,props:{className:[G]},children:[{type:b,tag:H,props:{className:[I,J]},children:[{type:b,tag:d,props:{},children:[{type:a,value:"import Foundation\nextension Bundle {\n    static let module = Bundle(path: \"(Bundle.main.bundlePath)\u002Fpath\u002Fto\u002Fthis\u002Ftargets\u002Fresource\u002Fbundle\")\n}\n复制代码\n"}]}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"对于 Swift 和 OC 分别可以使用下面这种方式，当然也可以使用 UIImage 自己的带有 "},{type:b,tag:d,props:{},children:[{type:a,value:"Bundle"}]},{type:a,value:" 参数的 Api"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:h,props:{alt:i,src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F173902531503d6fb.webp"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"由于 "},{type:b,tag:d,props:{},children:[{type:a,value:"module"}]},{type:a,value:" 是内部属性，所以这种方式只能访问自己模块内部的资源文件，无法跨模块访问。如果想在一个公共模块提供外部模块使用的资源，则需要自己创建一个资源访问器。关于这一点，使用过 Cocoapods 的 "},{type:b,tag:d,props:{},children:[{type:a,value:"resource_bundle"}]},{type:a,value:" 功能的开发者可能比较了解，可以采用 bundle 路径方式访问。如果不单独建立一个公共资源模块，则不需要考虑这么多。"}]},{type:a,value:c},{type:b,tag:k,props:{id:v},children:[{type:b,tag:g,props:{href:"#%E6%9C%AC%E5%9C%B0%E5%8C%96",ariaHidden:l,tabIndex:m},children:[{type:b,tag:n,props:{className:[o,p]},children:[]}]},{type:a,value:v}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"首先需要在配置文件中配置默认的语言："}]},{type:a,value:c},{type:b,tag:F,props:{className:[G]},children:[{type:b,tag:H,props:{className:[I,J]},children:[{type:b,tag:d,props:{},children:[{type:a,value:"let package = Package(\n    name: \"MyLibrary\",\n    defaultLocalization: \"en\",\n    products: [\n        \u002F\u002F Products define the executables and libraries a package produces, and make them visible to other packages.\n    ],\n    dependencies: [\n        \u002F\u002F Dependencies declare other packages that this package depends on.\n        \u002F\u002F .package(url: \u002F* package url *\u002F, from: \"1.0.0\"),\n    ],\n    targets: [\n        \u002F\u002F Targets are the basic building blocks of a package. A target can define a module or a test suite.\n        \u002F\u002F Targets can depend on other targets in this package, and on products in packages this package depends on.\n)\n复制代码\n"}]}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"然后根据你需要的语言创建对应的文件夹，文件名为对应的语言，后缀命名成 "},{type:b,tag:d,props:{},children:[{type:a,value:K}]},{type:a,value:" ，并在文件夹中创建 "},{type:b,tag:d,props:{},children:[{type:a,value:V}]},{type:a,value:E},{type:b,tag:d,props:{},children:[{type:a,value:W}]},{type:a,value:" 文件，如下图所示："}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:h,props:{alt:i,src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F1739025920dbcac9.webp"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"使用时："}]},{type:a,value:c},{type:b,tag:F,props:{className:[G]},children:[{type:b,tag:H,props:{className:[I,J]},children:[{type:b,tag:d,props:{},children:[{type:a,value:"Button(action: roll, label: {\n                Text(\"Roll\", bundle: Bundle.module)\n                    .font(.title)\n            })           \n复制代码\n"}]}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"在测试时可以通过声明环境变量设置语言环境："}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:h,props:{alt:i,src:"https:\u002F\u002Fcdn.jsdelivr.net\u002Fgh\u002Fquicktouch\u002Fimage@main\u002Fimg\u002F1739025b67059b45.webp"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"从文件夹声明中可以看出，语言国际化需要新建一个后缀名为 "},{type:b,tag:d,props:{},children:[{type:a,value:K}]},{type:a,value:" 的文件夹，这也符合上面说的 “具有使用目的的文件”，所以这里不需要在 "},{type:b,tag:d,props:{},children:[{type:a,value:q}]},{type:a,value:" 中额外配置属性。"}]},{type:a,value:c},{type:b,tag:k,props:{id:w},children:[{type:b,tag:g,props:{href:"#%E6%80%BB%E7%BB%93",ariaHidden:l,tabIndex:m},children:[{type:b,tag:n,props:{className:[o,p]},children:[]}]},{type:a,value:w}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"这个简短的内容主要介绍了如何在 Package 中添加本地资源文件和本地化的过程，大概是几个要点："}]},{type:a,value:c},{type:b,tag:"ol",props:{},children:[{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"对于使用目的明确的文件，比如以 "},{type:b,tag:d,props:{},children:[{type:a,value:P}]},{type:a,value:"、 "},{type:b,tag:d,props:{},children:[{type:a,value:".xib"}]},{type:a,value:" 、 "},{type:b,tag:d,props:{},children:[{type:a,value:".storyboard"}]},{type:a,value:" 等为后缀的文件，不需要在 "},{type:b,tag:d,props:{},children:[{type:a,value:q}]},{type:a,value:" 中添加任何配置。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"对于用途不明确的文件，比如纯文本文件、脚本文件，则视情况在 "},{type:b,tag:d,props:{},children:[{type:a,value:q}]},{type:a,value:" 中使用不同属性配置（以下均是文件、文件夹均可配置）：\n"},{type:b,tag:D,props:{},children:[{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"对于不需要被外部引用的，例如内部的开发者文档 "},{type:b,tag:d,props:{},children:[{type:a,value:"README"}]},{type:a,value:" ，需要配置在 "},{type:b,tag:d,props:{},children:[{type:a,value:"target.excludes"}]},{type:a,value:S}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"对于运行时有用到，可以被系统根据平台优化的文件，比如各种图片，需要配置在 "},{type:b,tag:d,props:{},children:[{type:a,value:"target.resource.process"}]},{type:a,value:X}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"对于运行时有用到，不存在优化的文件，比如各种图片，需要配置在 "},{type:b,tag:d,props:{},children:[{type:a,value:"target.resource.copy"}]},{type:a,value:X}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"本地化过程，首先需要在配置文件中声明默认语言，然后根据语言创建 "},{type:b,tag:d,props:{},children:[{type:a,value:K}]},{type:a,value:" 文件夹，再在文件夹里创建 "},{type:b,tag:d,props:{},children:[{type:a,value:V}]},{type:a,value:E},{type:b,tag:d,props:{},children:[{type:a,value:W}]},{type:a,value:" 文件，写上本地化的字符串。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"除了上面这些内容，回到 Swift Package Manager 本身，尽管在日渐完善，但是个人觉得距离广泛使用真的很遥远。当前的环境下，swift 虽然在国内几年内会基本替代 OC 成为 iOS 原生主要开发语言，但整个环境并没有合适的理由阻止跨端开发逐渐成为主流。从 H5 到 RN、weex，再到现在的 flutter，再映射到配置不断优化的硬件上 性能差距慢慢被缩小，而对业务所希望的热更新也不是技术问题。对于剩余的 Swift 开发者中，SwiftPM 该如何说服他们放弃成熟的 CocoaPods 来使用它呢？仅仅靠一个 “官方” 的标签远远不够。"}]},{type:a,value:c},{type:b,tag:k,props:{id:x},children:[{type:b,tag:g,props:{href:"#%E5%BC%95%E7%94%A8",ariaHidden:l,tabIndex:m},children:[{type:b,tag:n,props:{className:[o,p]},children:[]}]},{type:a,value:x}]},{type:a,value:c},{type:b,tag:D,props:{},children:[{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:g,props:{href:"https:\u002F\u002Fdeveloper.apple.com\u002Fvideos\u002Fplay\u002Fwwdc2020\u002F10169\u002F",rel:[y,z,A],target:B},children:[{type:a,value:"Swift packages: Resources and localization"}]}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:g,props:{href:"https:\u002F\u002Fdeveloper.apple.com\u002Fforums\u002Fthread\u002F650158",rel:[y,z,A],target:B},children:[{type:a,value:"What is Bundle.module"}]}]},{type:a,value:c}]}]},dir:"\u002Fwiki\u002FiOS\u002F包管理工具",path:Y,extension:".md",createdAt:Z,updatedAt:Z},prev:{slug:_,date:$,title:aa},next:{slug:ab,title:ac,date:ad},scrollTop:ae,sideCategory:[{folderName:"iOS",articles:[{slug:"iOS-Swift-ObjectMapper 指南",title:"Swift-ObjectMapper 指南",date:"2016-05-23 16:13",path:"\u002Fwiki\u002FiOS\u002FiOS-Swift-ObjectMapper 指南"},{slug:"iOS-URL Schemes && Universal Links 简单使用",title:"URL Schemes && Universal Links 简单使用",date:"2017-02-14T00:00:00.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-URL Schemes && Universal Links 简单使用"},{slug:"iOS-YYModel",title:"YYModel几种使用场景",date:af,path:"\u002Fwiki\u002FiOS\u002FiOS-YYModel"},{slug:"iOS-ios-useful-link",title:"'实用链接",date:"2017-07-14T16:58:04.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-ios-useful-link"},{slug:"iOS-mrpeak杂货铺-iOS应用层架构之CDD",title:"(转)mrpeak杂货铺-iOS应用层架构之CDD",date:ag,path:"\u002Fwiki\u002FiOS\u002FiOS-mrpeak杂货铺-iOS应用层架构之CDD"},{slug:"iOS-检测离屏渲染与绘制高性能圆角",title:"(待)检测离屏渲染与绘制高性能圆角",date:"2017-08-17T10:03:56.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-检测离屏渲染与绘制高性能圆角"},{slug:"iOS-深度重构UIViewController",title:"(转)mrpeak杂货铺-深度重构UIViewController",date:"2017-11-19T21:33:42.000Z",path:"\u002Fwiki\u002FiOS\u002FiOS-深度重构UIViewController"},{slug:"iOS-添加字体库",title:"使用第三方字体",date:ag,path:"\u002Fwiki\u002FiOS\u002FiOS-添加字体库"}],children:[{folderName:"3part",articles:[{slug:"3part-umeng-install",title:"快速集成友盟分享",date:"2018-03-01 16:11",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-umeng-install"},{slug:"3part-快速集成微信支付",title:"快速集成微信\u002F支付宝\u002F银联",date:"2017-11-17T16:19:25.000Z",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-快速集成微信支付"},{slug:"3part-快速集成百度地图",title:"集成百度地图、百度导航",date:"2017-08-11T11:24:43.000Z",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-快速集成百度地图"},{slug:"3part-阿里云视频点播集成",date:"2020-10-26T01:10:15.000Z",title:"阿里云视频点播VOD",path:"\u002Fwiki\u002FiOS\u002F3part\u002F3part-阿里云视频点播集成"}],children:[]},{folderName:"Autolayout",articles:[{slug:"Autolayout-baseline",title:"label底部对齐、顶部对齐",date:ah,path:"\u002Fwiki\u002FiOS\u002FAutolayout\u002FAutolayout-baseline"}],children:[]},{folderName:"Error",articles:[{slug:"Error-2017-07-31",title:"Undefined symbols for architecture ..",date:"2017-07-31T08:52:40.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-2017-07-31"},{slug:"Error-Shell-Script-Invocation-Error",title:"'Shell Script Invocation Error'",date:"2017-07-20T14:27:04.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-Shell-Script-Invocation-Error"},{slug:"Error-gesture",title:"tableViewCell的点击和tapGestureRecognizer冲突的处理",date:"2016-11-19T21:33:42.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-gesture"},{slug:"Error-崩溃分析",date:"2020-11-11T07:28:34.000Z",title:"崩溃分析(转载)",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-崩溃分析"},{slug:"Error-竖屏下视频全屏播放",title:"(转)竖屏下视频全屏播放",date:"2017-08-01T15:23:01.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-竖屏下视频全屏播放"},{slug:"Error-证书过期或者移除对app的影响",title:"证书过期或者移除对app的影响",date:"2018-01-11T13:49:33.000Z",path:"\u002Fwiki\u002FiOS\u002FError\u002FError-证书过期或者移除对app的影响"}],children:[]},{folderName:"Objective-C",articles:[{slug:"Objective-C-KVO - Observe property of an object contained in a NSArray",title:"KVO - Observe property of an object contained in a NSArray",date:"2017-09-28 22:26",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-KVO - Observe property of an object contained in a NSArray"},{slug:"Objective-C-NSArrayFilter",title:"NSArray: filteredArrayUsingPredicate",date:"2017-09-14 16:24",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-NSArrayFilter"},{slug:"Objective-C-NSRecursiveLock",date:"2020-10-27T00:52:16.000Z",title:"NSRecursiveLock",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-NSRecursiveLock"},{slug:"Objective-C-NSStringCompareOptions",title:"NSStringCompareOptions",date:"2017-07-10T17:13:25.000Z",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-NSStringCompareOptions"},{slug:"Objective-C-containsObject-or-removeObject",title:"containsObject or removeObject",date:"2015年04月12日09:55:35",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-containsObject-or-removeObject"},{slug:"Objective-C-get-lunarholidays",title:"节气、节假日计算",date:"2017-07-13T09:30:26.000Z",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-get-lunarholidays"},{slug:"Objective-C-use-dispatch_queue_t-with-strong",title:"dispatch_queue_t 用strong来修饰",date:af,path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-use-dispatch_queue_t-with-strong"},{slug:"Objective-C-农历",title:"农历",date:"2017-07-11T13:12:46.000Z",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-农历"},{slug:"Objective-C-常用的宏",title:"常用的宏",date:"2015-03-04 11:11",path:"\u002Fwiki\u002FiOS\u002FObjective-C\u002FObjective-C-常用的宏"}],children:[]},{folderName:"StatusBar",articles:[{slug:"StatusBar-how-to-detect-touches-in-status-bar",title:"获取StatusBar的点击事件",date:ai,path:"\u002Fwiki\u002FiOS\u002FStatusBar\u002FStatusBar-how-to-detect-touches-in-status-bar"},{slug:"StatusBar-ios-status-bar-style",title:"修改StatusBarStyle以及statusBar的背景颜色",date:ai,path:"\u002Fwiki\u002FiOS\u002FStatusBar\u002FStatusBar-ios-status-bar-style"}],children:[]},{folderName:"UIKit",articles:[{slug:"UIKit-UIAlertController修改文字对齐方式",date:"2020-10-23T08:07:07.000Z",title:"UIAlertController修改文字对齐方式",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-UIAlertController修改文字对齐方式"},{slug:"UIKit-UIDynamic Animator",title:"UIDynamic Animator",date:"2016-07-20T16:13:11.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-UIDynamic Animator"},{slug:"UIKit-UISplit​View​Controller 学习笔记",title:"UISplit​View​Controller 学习笔记",date:"2017-04-07T00:00:00.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-UISplit​View​Controller 学习笔记"},{slug:"UIKit-searchBar-style",title:"如何修改searchBar的样式",date:"2017-05-14T19:01:01.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-searchBar-style"},{slug:"UIKit-uioffset",title:"UIOffset",date:"2017-08-02T15:30:01.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-uioffset"},{slug:"UIKit-屏幕旋转.md",date:"2020-11-09T06:04:42.000Z",title:"屏幕旋转",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-屏幕旋转.md"},{slug:"UIKit-离屏渲染",title:"(转)关于iOS离屏渲染的深入研究",date:"2020-04-06T00:00:00.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-离屏渲染"},{slug:"UIKit-给WebView添加个粗糙的加载动画",title:"给UIWebView添加个粗糙的加载动画",date:"2017-02-10T00:00:00.000Z",path:"\u002Fwiki\u002FiOS\u002FUIKit\u002FUIKit-给WebView添加个粗糙的加载动画"}],children:[]},{folderName:"UITextFeild",articles:[{slug:"UITextFeild-2018-01-16",title:"修改光标颜色和clear button的颜色",date:"2018-01-16T15:44:44.000Z",path:"\u002Fwiki\u002FiOS\u002FUITextFeild\u002FUITextFeild-2018-01-16"},{slug:"UITextFeild-uitextfeild-select-all",title:"默认选中文本",date:"2017-07-07 04:44",path:"\u002Fwiki\u002FiOS\u002FUITextFeild\u002FUITextFeild-uitextfeild-select-all"}],children:[]},{folderName:"keyboard",articles:[{slug:"keyboard-disable-3rd-keyboard",title:"禁用第三方键盘",date:ah,path:"\u002Fwiki\u002FiOS\u002Fkeyboard\u002Fkeyboard-disable-3rd-keyboard"}],children:[]},{folderName:"loc",articles:[{slug:"loc-2018-01-22",title:"CLPlacemark中文",date:"2018-01-22T14:36:49.000Z",path:"\u002Fwiki\u002FiOS\u002Floc\u002Floc-2018-01-22"},{slug:"loc-sim-locaiton-ios",title:"真机或模拟器修改定位位置",date:"2017-08-11T10:29:01.000Z",path:"\u002Fwiki\u002FiOS\u002Floc\u002Floc-sim-locaiton-ios"}],children:[]},{folderName:"tableView",articles:[{slug:"tableView-cell-seprateLine",title:"cell分割线的颜色",date:"2017-08-08T15:26:14.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-cell-seprateLine"},{slug:"tableView-compare-NSIndexPath",title:"compare NSIndexPath",date:"2017-08-15T17:01:49.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-compare-NSIndexPath"},{slug:"tableView-tabeleView 获取某个cell的高度",title:"tabeleView 获取某个cell的高度",date:"2017-05-09T10:36:29.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-tabeleView 获取某个cell的高度"},{slug:"tableView-taleview-headerfooterView-xib",title:"xib UITableViewHeaderFooterView",date:"2017-08-18T09:47:36.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-taleview-headerfooterView-xib"},{slug:"tableView-结合layoutMargins做tableViewCell的适配",title:"结合layoutMargins做cell的适配",date:"2017-08-20T21:55:52.000Z",path:"\u002Fwiki\u002FiOS\u002FtableView\u002FtableView-结合layoutMargins做tableViewCell的适配"}],children:[]},{folderName:Q,articles:[{slug:"xib-如何替换已有的控件",title:"如何替换已有的控件",date:"2017-09-07T10:51:38.000Z",path:"\u002Fwiki\u002FiOS\u002Fxib\u002Fxib-如何替换已有的控件"}],children:[]},{folderName:"代码片段",articles:[{slug:"代码片段-分割小说章节",title:"分割小说章节",date:"2017-01-18T15:12:12.000Z",path:"\u002Fwiki\u002FiOS\u002F代码片段\u002F代码片段-分割小说章节"},{slug:"代码片段-截图 截长图 高清图",title:"截图 截长图 高清图",date:"2016-05-04 22:38",path:"\u002Fwiki\u002FiOS\u002F代码片段\u002F代码片段-截图 截长图 高清图"},{slug:"代码片段-读取未知类型的txt文件",title:"读取未知类型的txt文件 ",date:"2017-01-16 20:12",path:"\u002Fwiki\u002FiOS\u002F代码片段\u002F代码片段-读取未知类型的txt文件"}],children:[]},{folderName:"包管理工具",articles:[{slug:_,date:$,title:aa,path:"\u002Fwiki\u002FiOS\u002F包管理工具\u002F包管理工具-spm-introduce"},{slug:L,date:M,title:N,path:Y}],children:[]},{folderName:"日历",articles:[{slug:"日历-FSCalendar",title:"FSCalendar",date:"2017-07-11T08:48:12.000Z",path:"\u002Fwiki\u002FiOS\u002F日历\u002F日历-FSCalendar"}],children:[]},{folderName:"适配",articles:[{slug:ab,title:ac,date:ad,path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-NFC初试"},{slug:"适配-iOS11 Xcode9新功能新特性",title:"iOS11 Xcode9新功能新特性",date:aj,path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11 Xcode9新功能新特性"},{slug:"适配-iOS11 tableView适配不完全指南",title:"iOS11 tableView适配不完全指南",date:"2017-09-19 12:33",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11 tableView适配不完全指南"},{slug:"适配-iOS11刘海屏EdgeProtect相关",date:"2020-10-26T06:00:25.000Z",title:"iOS11刘海屏EdgeProtect相关",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11刘海屏EdgeProtect相关"},{slug:"适配-iOS11适配参考",title:"iOS11 适配参考",date:aj,path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS11适配参考"},{slug:"适配-iOS14hidesBottomBarWhenPushed兼容问题",date:"2020-10-23T08:53:49.000Z",title:"iOS14 hidesBottomBarWhenPushed兼容问题",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-iOS14hidesBottomBarWhenPushed兼容问题"},{slug:"适配-touch-id",title:"touch Id",date:"2017-08-04T13:46:10.000Z",path:"\u002Fwiki\u002FiOS\u002F适配\u002F适配-touch-id"}],children:[]},{folderName:"问与答",articles:[{slug:"问与答-为什么ui操作要在主线程",date:"2020-11-16T03:38:48.000Z",title:"为什么ui操作要在主线程",path:"\u002Fwiki\u002FiOS\u002F问与答\u002F问与答-为什么ui操作要在主线程"}],children:[]}]}]}],fetch:{},mutations:ae}}("text","element","\n","code","p","li","a","img","",2,"h2","true",-1,"span","icon","icon-link","package.swift","配置要求","添加和配置资源文件","构建过程","访问资源文件","本地化","总结","引用","nofollow","noopener","noreferrer","_blank","resource","ul"," 或者 ","div","nuxt-content-highlight","pre","language-text","line-numbers",".lproj","包管理工具-spm-resource-handle","2020-11-19T00:58:59.000Z","SWift Package Manager资源文件管理","blockquote",".xcassets","xib"," 和 "," 属性中。","process()","copy()",".strings",".stringsdict"," 属性里","\u002Fwiki\u002FiOS\u002F包管理工具\u002F包管理工具-spm-resource-handle","2021-10-15T10:03:44.816Z","包管理工具-spm-introduce","2020-11-18T08:08:33.000Z","Swift Package Manager介绍","适配-NFC初试","NFC初试","2017-06-07 18:31",void 0,"2017-08-31T09:32:08.000Z","2017-10-27T18:01:13.000Z","2017-08-19T16:10:51.000Z","2016-07-01T14:19:23.000Z","2017-09-20T15:20:33.000Z")));